<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="34">
  <CheatEntries>
    <CheatEntry>
      <ID>25330</ID>
      <Description>"Unreal Engine"</Description>
      <Options moHideChildren="1"/>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript Async="1">{$lua}
ObjectsPerThread=0x200
FNameIndexMultiplier= string.find(process:lower(),'chivalry2') and 2 or 1
function ue4config()
 local sub=targetIs64Bit() and 0 or 4
 if not UObject then UObject = {}end

 --if UE4ver&lt;=2 and targetIs64Bit() then ue4determineversion() end
-----------------------------
----------UE4 struct---------

 if not UE3 then

    UObject.ObjectId= 0xC-sub
    UObject.Class = 0x10-sub
    UObject.FNameIndex = 0x18-(sub*2)
    UObject.Outer = 0x20-(sub*2)

  if UE4ver&gt;=25 then
    UObject.super= 0x40
    UObject.member= 0x50
    UObject.nextmember= 0x20
    UObject.Offset= 0x4C
    UObject.propsize=0x3C
    UObject.bitmask= 0x7A
    UObject.Property= 0x78
    UObject.enumoffset = 0x40
    UObject.enummul = 0x10
    UObject.enumname = 0x0
    UObject.enumindex = 0x8

  elseif UE4ver&gt;=22 then
    UObject.super= 0x40
    UObject.member= 0x48

  else
    UObject.super= 0x30 -(sub*4)
    UObject.member= 0x38 -(sub*5)

  end

  if UE4ver&lt;25 then
    UObject.nextmember=0x28-(sub*3)
    UObject.Offset= 0x44-(sub*4)
    UObject.propsize= 0x34-(sub*3/2)
    UObject.bitmask= 0x72-(sub*8)

    UObject.Property= 0x70-(sub*8)

  end

  if UE4ver&lt;11 then
    UObject.Offset= 0x4C
  end

----------------------------
---------UE3 struct---------
--1.25
--[[
 elseif UE4ver&gt;=1 then

    UObject.ObjectId= 0x4
    UObject.Outer = 0x14
    UObject.FNameIndex = 0x18
    UObject.Class = 0x20
    UObject.Offset= 0x48
    UObject.super= 0x34
    UObject.member= 0x38
    UObject.nextmember=0x28
    UObject.propsize= 0x30
    UObject.bitmask= 0x60
    UObject.Property= 0x58

]]
--0.10246
 else
 --[[
    UObject.ObjectId= 0x20
    UObject.Outer = 0x28
    UObject.FNameIndex = 0x2C
    UObject.Class = 0x34

    UObject.Offset= 0x60

    UObject.super= 0x48
    UObject.member= 0x4C

    UObject.nextmember=0x3C
    UObject.propsize= 0x44
    UObject.bitmask= 0x70]]

 end

---------------------------
end


ue4type={
		['BoolProperty']=vtByte,
		['ByteProperty']=vtByte,
		['FloatProperty']=vtSingle,
        ['StructProperty']=vtDword,
		['IntProperty']=vtDword,
        ['NameProperty']=vtQword,
        ['Int64Property']=vtQword,
		['TextProperty']=vtPointer,
        ['StrProperty']=vtPointer,
        ['ArrayProperty']=vtPointer,
        ['MapProperty']=vtPointer,
        ['ClassProperty']=vtPointer,
		['ObjectProperty']=vtPointer}

function ue4versioncheck()
 --if true then return 0 end
 local fileversion,info =getFileVersion(enumModules()[1].PathToFile)
 if not info then return 0 end
 return tonumber(info.minor..'.'..info.release)
end

function FNameStringAlgo(FName,IndexOnly)

 if not FName then return nil end
 local UEver=UE4ver
 local sub=targetIs64Bit() and 0 or 4
 local size=targetIs64Bit() and 8 or 4
 local number,str,pointer
 if not IndexOnly then
   number=UEver&gt;2 and readInteger(FName+4) or 0
   FName=readInteger(FName)
 else
   if UEver~=nil and UEver&lt;=0 and readPointer('Core.FName::Names') then FName=readInteger(FName) and readInteger(FName) or FName end
   number=FName&gt;&gt;32 FName=FName&amp;0xFFFFFFFF
 end


 if not FName then return nil end

 if isMassEffect then
   local i=(FName&gt;&gt;0x1D)&amp;7
   FName=FName&amp;0x1FFFFFFF
   str=readString(readPointer(getAddress('FNamePool')+i*8)+FName+stringoffset)
   return str
 end

 if FNameList[FName] then
   if number&gt;0 then return FNameList[FName]..'_'..number-1 end
   return FNameList[FName]
 end

 local CFName=FName

 if readPointer(FNameString) then
   if not FNameStringStub then FNameStringStub=createExecuteCodeExStub(0,FNameString,0,0)end
   if not FNameStringRE then FNameStringRE=createRemoteExecutor()end

   if not mem then mem=allocateMemory(0x100)end
   writeQword(mem+0x50+UObject.FNameIndex,FName)
   FNameStringRE.executeStub(FNameStringStub,{mem+0x50,mem})
   str=readPointer(mem)
   if str then str=readString(str,readInteger(mem+0x8)*2,true) end
   --deAlloc(mem)

 elseif UEver&gt;=23 then
  local i=(FName&gt;&gt;0x10)
  FName=(FName&amp;0xFFFF)&lt;&lt;FNameIndexMultiplier
  pointer=readPointer(FNamePool+i*size)

  local le =  readSmallInteger(pointer+FName)
  if not le then return nil end
  le=le&gt;&gt;6
  if le&gt;200 then return nil end
  local widechar= true and readBytes(pointer+FName,1)==1 or false
  --printf('%X %i %s',pointer+FName,le,widechar)

  if not stringoffset and CFName&gt;0 and CFName&lt;7 and le&gt;=10 and le&lt;=15 then
    le=(widechar and le*2 or le)-1
    for k=2,0x20,2 do
      if string.find(readString(pointer+FName+k,le,widechar),'ByteProperty') then stringoffset=k break end
      --print(k)
    end
  end
  le=(widechar and le*2 or le)-1

  if not stringoffset then return end

  str=readString(pointer+FName+stringoffset,le,widechar)
 else
  local i

  if FNamePool2 then FName= FName &lt;0x25A and readInteger(FName*4+FNamePool) or FName
  else
    i= not UE3 and (FName&gt;&gt;0xE) or 0
    FName= (not UE3 and (FName&amp;0x3FFF) or (FName&amp;0x7FFFF)) *  (8-sub)
  end


--  printf('%X',i)
--  printf('%X',FName)


  local pointer
  if FNamePool2 then
    pointer=readPointer(FNamePool2)+FName
  else
    pointer=readPointer(FNamePool+i*size)
    if not readPointer(pointer) then return nil end
    pointer=readPointer(pointer+FName)
  end

  --print(string.format('%X',pointer))

  if not readPointer(pointer) then return nil end
  local pointers,pointers2=pointer
  if stringoffset2 then pointer=readPointer(pointer+stringoffset2)end
  pointers2=pointer

  --print(string.format('%X',pointer))

  --local offset=UE4ver&gt;=22 and 0xC-sub or 0x10-(sub*2)
  if CFName==1 and not stringoffset then

     for k=0,0x30,4 do
        str=readString(pointer+k,13)
        if string.find(str,'ByteProperty') then stringoffset=k break end
      end

      if not stringoffset then
        for k=0,0x30,4 do
          str=readString(pointer+k,13*2,true)
          if string.find(str,'ByteProperty') then stringoffset=k forcewidechar=true break end
        end
      end

      pointer=pointers

     for j=0, stringoffset-4,4 do
       if readInteger(pointer+j)==2 then stringoffsetid=j end
     end
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
  --print(string.format('%X',offset))

  else
  if not stringoffset then return end
  --print(string.format('%X',pointer))

  pointer=pointers

  local widechar=stringoffsetid and (readInteger(pointer+stringoffsetid)&amp;1==1 or false) or false

  pointer=pointers2

  if stringoffset2 and not readPointer(pointer) then pointer=pointers+stringoffset2 end

  widechar= forcewidechar and true or widechar

  str= readString(pointer+stringoffset,200,widechar)

  if not str then str= readString(pointer+stringoffset,100,widechar) end
  if not str then str= readString(pointer+stringoffset,50,widechar) end
  if not str then str= readString(pointer+stringoffset,30,widechar) end
  if not str then
   local le=0
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
   while(true)do
    if le&gt;50 then break end
    if readBytes(pointer+stringoffset+le)==0 then break end
    le=le+1
   end
   str= readString(pointer+stringoffset,le)
  end
  --print(stringoffset)


 end end
 if not str then return nil end
 if number&gt;0 then return str..'_'..number-1 end
 --print(str)
 FNameList[CFName]=str
 --print(str)
 return str
end

function GetNameAlgo(object)
 if not object then return nil end
--[[
 if ObjectList[object] then --print(ObjectList[object])
   return ObjectList[object]
 end]]
 local pointer,size,str1,str2=readPointer(object+UObject.Class),targetIs64Bit() and 8 or 4
 if not pointer then return nil end
 --print(string.format('%X',fnameoffset))
 --print(string.format('%X',object+fnameoffset))
 str1=FNameStringAlgo(readInteger(pointer+UObject.FNameIndex),true)

 --print(str1)
 --if readInteger(pointer+fnameoffset+4)~=0 then return nil end

 str2=FNameStringAlgo(readInteger(object+UObject.FNameIndex),true)
 --print(str2)
 if not str2 then str2=FNameStringAlgo(readInteger(object+UObject.FNameIndex-8),true)end
 --if str2=='None' then str2=FNameStringAlgo(readInteger(pointer+UObject.Outer+size),true)end
 if not str1 or str1=='None' or not str2 or str2=='None' then return nil end


 str1=str1..' '..str2
 --print(ObjectList[object])
 ObjectList[object]=str1
 return str1
end

function GetFullNameAlgo(object)
 if not object then return nil end
 --if ObjectList[object] then return ObjectList[object] end
 local pathoffset=UObject.Outer
 local fnameoffset=UObject.FNameIndex
 local str=GetNameAlgo(object)
 if not str then return nil end
 local number=readInteger(object+fnameoffset+4)
 local typ=str:sub(1,string.find(str,' ')-1)
 local isProperty=string.find(typ,'Property')
 if not isProperty then isProperty=string.find(typ,'Function') end
 local pointer=readPointer(object+pathoffset)
 while(true)do
  if not pointer or pointer==0 then break end
  local stri=GetNameAlgo(pointer)
  if not stri then break end
  typ=stri:sub(1,string.find(stri,' ')-1)
  local isPropertyc=string.find(typ,'Property')
  if not isPropertyc then isPropertyc=string.find(typ,'Function') end
  stri=string.sub(str,1,string.find(str,' '))..stri:sub(string.find(stri,' ')+1,stri:len())
  local num=readInteger(pointer+fnameoffset+4)

  if number~=num and num==0 or  not isPropertyc and isProperty then stri=stri..':'
  else stri=stri..'.' end
  number=num
  isProperty=isPropertyc

  str=stri..string.sub(str,string.find(str,' ')+1,str:len())
  pointer=readPointer(pointer+pathoffset)

  if string.find(str,'%./') then
    stri=string.sub(str,1,string.find(str,' '))
    str=stri..str:sub(string.find(str,'%./')+1,str:len())
  break end

 end
 if not str then return nil end
 --ObjectList[object]=str
 return str
end

function GetFullNameSuperAlgo(object)
  local super=UObject.super
  local str1 = GetFullNameSafeAlgo(object)
  if not str1 then return nil end
  local pointer = readPointer(object+super)
  if pointer then
    local str2 = GetFullNameSafeAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function GetFullNameSafesAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 local str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end

function GetFullNameSafeAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local str= GetFullNameAlgo(object)
 if str then return str end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str3 then str3=GetFullNameSafesAlgo(pointer)end

 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end

function FindString(this,namestr,start,stop,isNoIndex)
  local acclen=0
  for i=start,stop do
    local name=FNameStringAlgo(i+acclen,true)
    if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
      --print(name)
      if namestr==name then FNameResult=i+acclen return end
      if isNoIndex then acclen=acclen+name:len()end
    end
  end
end


function FindStringFName(namestr,isNoIndex,skipParse)
  local size
  if not skipParse then ue4parsetableFNamePool() end
  if FNamePool2 then size=readInteger(FNamePool2+8)
  elseif UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
  elseif not UE3 then size=(#FNameDict&lt;&lt;0xE)-1
  else size=math.floor(FNameDict[1]/4) end
  local count=ObjectsPerThread
  size=math.floor((size/count)+0.5)
  FNameResult=nil
  local result
  local num,start,stop=count,0,0
  for i=0,size do
    start=i*num
    stop=(i+1)*num
    if FNameResult then break end
    createThread(FindString(this,namestr,start,stop-1,isNoIndex))
  end
  result=FNameResult
  FNameResult=nil
  return result
end

function getregionsize(address)
local allregion=enumMemoryRegions()
 for i=#allregion,1,-1 do
  if allregion[i].BaseAddress&lt;=address then
   local BaseAddress=allregion[i].BaseAddress
   local RegionSize=allregion[i].RegionSize
   local curSize=BaseAddress+RegionSize-address
   return curSize,RegionSize,BaseAddress,i
  end
 end
end

sub=targetIs64Bit() and 0 or 4

function ue4parsetableFNamePool()
  ObjectList={}
  FNameList={}
  if readPointer(FNameString) or string.find(process,'StateOfDecay2')then return end
  local pool=getAddressSafe('FNamePool')
  if pool then
    local pointer,pointers
    if not readPointer(readPointer(pool)) then pointer=pool+0x10
    else
      pointer=pool
      if readPointer(readPointer(readPointer(pointer)))then
        if readPointer(readPointer(readPointer(readPointer(pointer))))then
          pointer=readPointer(pointer)
        end
      end
    end
    if not readPointer(pointer)then pointer=readPointer(pool2+0x10)end
    FNamePool=pointer
    FNameDict={}
    local j=0
    for i=0,500 do
      pointers=readPointer(pointer+i*(8-sub))
      if readPointer(pointers) then
        FNameDict[i+1]=getregionsize(pointers)
      else j=j+1 end
      if j&gt;3 then break end
    end
  end


  if not isMassEffect and UE3==nil then
    print('Finding /Script/CoreUObject...')
    local CoreUObject=FindStringFName('/Script/CoreUObject',isMassEffect,true)
    if not CoreUObject then UE3=true if(UE4ver and UE4ver&gt;7 or not UE4ver)then UE4ver=ue4versioncheck() end
    else UE3=false end
  elseif isMassEffect then UE3=true end
  print('FNamePool parsed...')
end

function ue4parsetables()
 local size=targetIs64Bit() and 8 or 4
 ue4parsetableFNamePool()
 local pool2=getAddressSafe('GUObjectArray')
 if pool2 then
  if NOGUObjectsize then
    GUObjectsize=0xFFFFFFFF
    if not readPointer(readPointer(GUObjectAddress))then
      GUObjectAddress=allocateMemory(0x100) writePointer(GUObjectAddress,pool2)
    end
    printf('%X',GUObjectAddress)
    return
  end

  local pointer,pointers=readPointer(pool2)
  GUObjectsize=readInteger(pool2+size)
  if not readPointer(pointer)then GUObjectsize=readInteger(pool2+0x10+size*2+4) GUObjectsize= GUObjectsize==0xFFFFFFFF and readInteger(pool2+0x10+size+4)or GUObjectsize  pointer=readPointer(pool2+0x10)end
  if not readPointer(readPointer(pointer)) then pointer=pointer+0x10 end
  if not readPointer(readPointer(readPointer(readPointer(readPointer(pointer))))) or
  not inModule(readPointer(readPointer(readPointer(readPointer(pointer)))))or
  (UObject and UObject.Class and UObject.FNameIndex and UObject.Outer and GetFullNameSafeAlgo(readPointer(pointer)))
  then pointer=pool2 end
  for i=0,0x100,4 do
    if readPointer(readPointer(readPointer(readPointer(readPointer(pointer+i))))) and readPointer(readPointer(readPointer(readPointer(readPointer(pointer+i)))))~=0 then pointer=pointer+i break end
  end
  printf('%X',pointer)
  GUObjectAddress=pointer

 end
end

function ue4parsetable()
  ue4parsetables()
  local size,val=targetIs64Bit() and 8 or 4,0x80
  local pointerss,pointer,pointers,pointer3,flag1=readPointer(GUObjectAddress)

  for o=4,(UE3 and size or 8*4),4 do
  for k=0,10*o,o do
    pointers=readPointer(pointerss+k)
    if not checkvalue(pointers,0x50,k/o,2) then break end
    if k==(10*o)then UObjectMul=o printf('%X',o)flag1=true end
  end
  if flag1 then break end
  end

::doit::
  if not UObjectMul then

    local ObjectScanner={'Object scanner'}
    unregisterSymbol('GUObjectArray')
    print(UE4ver)
    for i=1,#ObjectScanner do
      rec=getAddressList().getMemoryRecordByDescription(ObjectScanner[i])
      if rec and not rec.Active then
        rec.Active=true
        while rec.AsyncProcessing do sleep(100) end
      end
      if readPointer('GUObjectArray') then break end
    end
    if not readPointer('GUObjectArray') then error('GUObjectArray not found!')
    else return ue4parsetable() end
  end
  --if not UObject.FNameIndex then

    if not UObject then UObject={} end

    for i=0,10 do
      pointer = readPointer(pointerss+i*UObjectMul)
      pointers= checkvalue(pointer+size,0x80,'Object',1,true)
      if pointers then
        printf('%X',i*UObjectMul)
        UObject.FNameIndex=pointers-pointer
        UObject.ObjectId=checkvalue(pointer+size,val,i,4)-pointer
        for j=4,0x80,4 do
          pointers=readPointer(pointer+j)
          if readPointer(pointers) then
            pointer3=FNameStringAlgo(readInteger(pointers+UObject.FNameIndex),true)
            if pointer3 and pointer3:find('Core') then UObject.Outer=j break end
          end
        end
        for j=4,0x80,4 do
          pointers=readPointer(pointer+j)
          if readPointer(pointers) then
            pointer3=FNameStringAlgo(readInteger(pointers+UObject.FNameIndex),true)
            if pointer3 and pointer3:find('Class') then UObject.Class=j break end
          end
        end
        break
      end
    end
    if not UObject.FNameIndex then UObjectMul=nil goto doit end
    --printf('ObjectId=%X\nFNameIndex=%X\nClass=%X\nOuter=%X',UObject.ObjectId,UObject.FNameIndex,UObject.Class,UObject.Outer)
  --end
  return true
end


function ue4parsetablecheck()
  if not readPointer(GUObjectAddress) or not readPointer(FNamePool) then return ue4parsetable() end
  local pointer
  pointer=readPointer(readPointer(GUObjectAddress))
  if not ObjectTable or not ObjectTable[1] or not FullNameList or (ObjectTable[1].Address ~= pointer) then return ue4parsetable() end
--[[
  local Address,FullName
  for i=1,#ObjectTable do
    if ObjectTable[i] and i&gt;#ObjectTable-0x10 then FullName=ObjectTable[i].Type..' '..ObjectTable[i].FullName Address=ObjectTable[i].Address  break end
  end

  if not GetFullNameSafeAlgo(Address) or FullName~=GetFullNameSafeAlgo(Address) then return ue4parsetable()end
]]
 return false
end

function FindObject(this,pointer,start,stop,fullname,name)
  local FullName,Name,Data,pointers=fullname,name
  for j=start,stop do
    if StaticFindObjectAlgoFoundAddress then break end
    pointers=readPointer(pointer+j*UObjectMul)
    if not readPointer(pointers) then break end
    Data=SaveObject(pointers)
    if FullName and FullNameList[FullName] then break end
    if Data and Name and string.find(Data.Name:lower(),Name:lower()) then StaticFindObjectAlgoFoundAddress=Data.Address break end
  end
end

if not FullNameList then FullNameList={}end
if not ObjectLists then ObjectLists={}end
if not ObjectTable then ObjectTable={}end
if not IgnoreList then IgnoreList={} end
if not HighestObjectID then HighestObjectID=0 end
if not totalobjects then totalobjects=0 end
if not totalproperties then totalproperties=0 end

function StaticFindObjectAlgo(fullname,name)
  StaticFindObjectAlgoFoundAddress=nil
  if fullname then fullname=fullname:lower() end
  if ue4parsetablecheck() or not FullNameList then
    FullNameList={}
    ObjectLists={}
    ObjectTable={}
    HighestObjectID=0
  end
  if FullNameList[fullname] then return FullNameList[fullname].Address end

  local count=ObjectsPerThread
  local sizess= UObjectMul*count
  local ObjectId=UObject.ObjectId
  local num,start,stop
  totalobjects=0
  local size,pointer=targetIs64Bit() and 8 or 4

  for i=0,0x1000,size do
    pointer=readPointer(GUObjectAddress+i)
    printf('UObjectArray:%X',i)
    if not readPointer(pointer) then break end
    size=getregionsize(pointer)
    num,start,stop=count,0,0
    for j=0,math.floor(size/sizess) do
      start=stop
      stop=stop+num
      --print(start..'~'..stop)

      createThread(FindObject(this,pointer,start,stop-1,fullname,name))
      if FullNameList[fullname] then return FullNameList[fullname].Address end
    end
  end
  local address=StaticFindObjectAlgoFoundAddress
  return address
end

function BasicObject(this,pointer,start,stop)
  local Data,pointers
  for j=start,stop do
    pointers=readPointer(pointer+j*UObjectMul)
    if not readPointer(pointers) then break end
    Data=SaveObject(pointers)
  end
  Threadlist[#Threadlist]=nil
end
totalproperties=0
IgnoreList={}
function BasicEnumObject()
  --ue4parsetablecheck()
  IgnoreList={}
  ObjectLists={}
  ObjectTable={}
  Threadlist={}
  FullNameList={}
  HighestObjectID=0
  starttime=os.clock()
  local count=ObjectsPerThread
  local sizess= UObjectMul*count
  local ObjectId=UObject.ObjectId
  local num,start,stop
  totalobjects=0
  totalproperties=0
  local size,pointer=targetIs64Bit() and 8 or 4

  for i=0,0x1000,size do
    pointer=readPointer(GUObjectAddress+i)
    printf('UObjectArray:%X',i)
    if not readPointer(pointer) then break end
    size=getregionsize(pointer)
    num,start,stop=count,0,0
    for j=0,math.floor(size/sizess) do
      start=stop
      stop=stop+num
      --print(start..'~'..stop)
      Threadlist[#Threadlist+1]=createThread(BasicObject(this,pointer,start,stop-1))
    end
  end
  if UE4ver&gt;=23 and totalproperties&lt;100 and ue4versioncheck()&lt;2 then UE4ver=25 end
  for i=0,10000 do
    if #Threadlist==0 then break end
    sleep(1)
  end
  BasicEnumObjectCooldown=true
  createTimer(180000, function()BasicEnumObjectCooldown=nil end)
  print(string.format('\nA Total of %u objects has been found in %.3f seconds',totalobjects,os.clock()-starttime))
end

function UperNameList(ObjectData,NameTable)
  if not NameTable then NameTable={} end
  if ObjectData.Name=='Object' then return NameTable end
  for i=1,#NameTable do
    if NameTable[i]==ObjectData.Name..'.' then return NameTable end
  end

  NameTable[#NameTable+1]=ObjectData.Name..'.'
  if ObjectData.Uper then
    for i=1,#ObjectData.Uper do
      UperNameList(ObjectData.Uper[i],NameTable)
    end
  end
  return NameTable
end

function registerMemberAlgo()
  UEMember={}
  UEMemberClassFullName={}
  UEMemberStrTable={'{$lua}\nif syntaxcheck then return end\n[ENABLE]\nUEMember = { '}
  local size,Super=HighestObjectID+10
  for i=1,size do
    if ObjectTable[i] and ObjectTable[i].Member then
      Class=UperNameList(ObjectTable[i],{''})
      Super=ObjectTable[i].Super
      for k=0,5 do
        if not Super or Super.Name=='Object' then break end
        Class[#Class+1]=Super.Name..'.'
        Super=Super.Super
      end
      registerMember(ObjectTable[i],ObjectTable[i].FullName)
    end
  end
  Class=nil
  UEMemberStrTable[#UEMemberStrTable]=UEMemberStrTable[#UEMemberStrTable]:sub(1,UEMemberStrTable[#UEMemberStrTable]:len()-1)
  UEMemberStrTable[#UEMemberStrTable+1]='}\n[DISABLE]'
  --[[
  local rec=getAddressList().getMemoryRecordByDescription('UEMemberStr(DoNotTouch!)')
  if not rec then rec=getAddressList().createMemoryRecord()end
  rec.Type=vtAutoAssembler
  rec.Description='UEMemberStr(DoNotTouch!)'
  rec.Script=table.concat(UEMemberStrTable)]]
end


function registerMember(ObjectData,FullName,AddedName,AddedOffset)
  local Name,Offset
  if not AddedName then AddedName='' end
  if not AddedOffset then AddedOffset=0 end
  if ObjectData.Member then
    for j=1,#ObjectData.Member do
      if ObjectData.Member[j].Offset then
        Offset=AddedOffset+ObjectData.Member[j].Offset
        Name=ObjectData.Member[j].Name
        if string.find(ObjectData.Type,'UserDefinedStruct') and string.find(Name,'_') then Name=Name:sub(1,string.find(Name,'_')-1)end
        Name=AddedName..Name
        for i=1,#Class do
          if not UEMember[(Class[i]..Name):lower()] then
            UEMember[(Class[i]..Name):lower()]=Offset
            UEMemberStrTable[#UEMemberStrTable+1]=string.format("['%s']=%u,",(Class[i]..Name):lower(),Offset)
            UEMemberClassFullName[(Class[i]..Name):lower()]=FullName
          end
          if ObjectData.Member[j].Bit and not UEMember[(Class[i]..Name..'.Bit'):lower()] then
            UEMember[(Class[i]..Name..'.Bit'):lower()]=ObjectData.Member[j].Bit
            UEMemberStrTable[#UEMemberStrTable+1]=string.format("['%s']=%u,",(Class[i]..Name..'.Bit'):lower(),ObjectData.Member[j].Bit)
            UEMemberClassFullName[(Class[i]..Name..'.Bit'):lower()]=FullName
          end
        end
        if string.find(ObjectData.Member[j].Type,'StructProperty') and ObjectData.Member[j].Property then registerMember(ObjectData.Member[j].Property[1],FullName,Name..'.',Offset)end
      end
    end
  end
end

function registerFuncAlgo()
  if not UE_function then UE_function=createSymbolList()end
  UE_function.unregister()
  UE_function.clear()
  for i,ObjectData in pairs(ObjectLists) do
    if string.find(ObjectData.Type,'Function') and not string.find(ObjectData.Type,'Default__Function')then
      pointer=readPointer(ObjectData.Address+UObject.funct)
      if readPointer(pointer) then
        if not FuncSizeList[pointer] then FuncSizeList[pointer]=getFuncSize(pointer) end
        UE_function.addSymbol('UE_function',ObjectData.FullName,pointer,FuncSizeList[pointer])
      end
    end
  end
  UE_function.register()
end

function GetName1(pointer)
  local class=readPointer(pointer+UObject.Class)
  if not class then return nil end
  local typ=readInteger(class+UObject.FNameIndex)
  if not typ then return nil end
  local name=readInteger(pointer+UObject.FNameIndex)
  typ=FNameStringAlgo(typ,true)
  name=FNameStringAlgo(name,true)
  return typ,name,readPointer(pointer+UObject.Outer),class
end

function GetName2(pointer)
  if not readPointer(pointer) then return nil end
  local typ=readInteger(readPointer(pointer+8))
  if not typ then return nil end
  local name=readInteger(pointer+0x28)
  typ=FNameStringAlgo(typ,true)
  name=FNameStringAlgo(name,true)
  return typ,name,readPointer(pointer+0x10)
end

function getFuncSize(address)
  local i,j,k,l,m,o=0,0
  while i&lt;0x10000 do
    o=readQword(i+address)
    if not o then return 1 end
    k=string.format('%016X',o)
    if string.find(k,'CCC3') then i=i+8 break end
    --l={}for n=1,8 do  l[n]=k:sub(1,2) k=k:sub(3,k:len())end k=table.concat(l)
    l=string.find(k,'C3') or string.find(k,'EB') or string.find(k,'E9')
    if l then m=true end
    l=string.find(k,'CCCC')
    if l then k,j=k:gsub('CC','CC') end
    if j&gt;=2 or (j&gt;=2 and l and m) then i=i+8-(l/2) break end
    i=i+8
  end
  return math.floor(i)
end

function SaveObject(pointer)
   if not readPointer(pointer)then return nil end
   if ObjectLists[pointer] then return ObjectLists[pointer] end
   --if IgnoreList[pointer] then return nil end

   local objid=readInteger(pointer+UObject.ObjectId)
   if not objid then return nil end

   local UEver,typ,name,outer,class,super=UE4ver
   if UEver&lt;25 then typ,name,outer,class=GetName1(pointer)
   else typ,name,outer=GetName2(pointer)
     if not typ or not name then
       typ,name,outer,class=GetName1(pointer)
     end
   end

   --[[if not typ or not name and readPointer(readPointer(readPointer(pointer))) and readInteger(pointer+0xC)&lt;0xFFFF then
     for i=0,readInteger(pointer+0xC)-1 do
       IgnoreList[pointer]=true
       SaveObject(readPointer(readPointer(pointer)+i*UObjectMul))
     end
     return nil
   else]]
   if not typ or not name or typ:len()&gt;100 then --IgnoreList[pointer]=true
   return nil end

   local ObjectData,size,pointers,pointerss,Data,flag1={},targetIs64Bit() and 8 or 4

   ObjectData.Outer= outer~=0 and outer or nil
   ObjectData.Name=name
   ObjectData.Type=typ
   ObjectData.Address=pointer

   if not ObjectData.Name then
     --print(ObjectData.Address)
     ObjectData.Name='InvalidName'
   end
   if ObjectTable[objid+1] and ( not string.find(typ,'Property') or UE4ver&lt;25 ) then return ObjectTable[objid+1] end

   ObjectData.ObjectId=objid

   if objid&lt;0xFFFFFFF and ( not string.find(typ,'Property') or UE4ver&lt;25 ) then
     ObjectTable[objid+1]=ObjectData
     if HighestObjectID&lt;objid then HighestObjectID=objid end
   end

   ObjectLists[pointer]=ObjectData

   SaveObject(ObjectData.Outer)
   local dataNew,str,dataOld=ObjectData,ObjectData.Name

   for x=0,10 do
     if not dataNew.Outer or not ObjectLists[dataNew.Outer] then break end
     dataOld=dataNew
     dataNew=ObjectLists[dataNew.Outer]
     if (string.find(dataOld.Type,'Property') or string.find(dataOld.Type,'Function'))
     and (not string.find(dataNew.Type,'Property') and not string.find(dataNew.Type,'Function'))
     then
       str=dataNew.Name..':'..str
     else
       str=dataNew.Name..'.'..str
     end
   end
   ObjectData.FullName=str
   FullNameList[str:lower()]=ObjectData
   if class then
     class=SaveObject(class)
     if class then
       if not class.Instance then class.Instance={}end
       class.Instance[#class.Instance+1]=ObjectData
       ObjectData.Class=class
     end
   end

   totalobjects=totalobjects+1

   if UObject.super then
     super=readPointer(pointer+UObject.super)
     ObjectData.Super= super~=0 and super or nil
     if ObjectData.Super then ObjectData.Super=SaveObject(ObjectData.Super)end
     if ObjectData.Super then
       if not ObjectData.Super.Uper then ObjectData.Super.Uper={}end
       ObjectData.Super.Uper[#ObjectData.Super.Uper+1]=ObjectData
     end
   end

   if string.find(typ,'Property')then
     if UEver&gt;=23 then totalproperties=totalproperties+1 end
     if UObject.Offset and UObject.propsize and UObject.Property and UObject.bitmask then
       ObjectData.Offset=readSmallInteger(pointer+UObject.Offset)
       ObjectData.Propsize=readSmallInteger(pointer+UObject.propsize)
       if string.find(typ,'StructProperty') or string.find(typ,'ObjectProperty') then
         ObjectData.Property={SaveObject(readPointer(pointer+UObject.Property))}
         if not ObjectData.Property[1] then ObjectData.Property=nil end
       elseif string.find(typ,'MapProperty') or string.find(typ,'ArrayProperty') then
         ObjectData.Property={SaveObject(readPointer(pointer+UObject.Property)),SaveObject(readPointer(pointer+UObject.Property+size))}
         if not ObjectData.Property[1] then ObjectData.Property=nil end
       elseif string.find(typ,'BoolProperty')then ObjectData.Bit=readInteger(pointer+UObject.bitmask)end
     end
   else
     if UObject.member and UObject.nextmember then
       local member=SaveObject(readPointer(pointer+UObject.member))
       if member then--and (string.find(member.Type,'Function') or string.find(member.Type,'Property') or string.find(member.Type,'Enum') or string.find(member.Type,'Const') ) then
         ObjectData.Membersize=readInteger(pointer+UObject.member+size)
         LastObjectWithMember=ObjectData
         ObjectData.Member={member}
         for i=0,0x1000 do
           member=SaveObject(readPointer(member.Address+UObject.nextmember))
           if not member then break end
           if not string.find(member.Type,'Function') and member.Offset and member.Offset&gt;0 then ObjectData.Member[#ObjectData.Member+1]=member end
         end
       end
     end
   end

   if typ=='Function' and not string.find(str,'Default')then
     if not UObject.funct then
       print(typ..' '..str..string.format(' = %X',pointer))
       for i=UObject.ObjectId,0x130,4 do
         flag1=nil
         pointers=readPointer(pointer+i)
         if readPointer(pointers) and inModule(pointers) then
         --printf('%X',pointers)
           for j=0,0x30,size do
             if not inModule(readPointer(pointers+j))then break end
             if j==0x30 then
               printf('%X',i)
               for k=i-4,UObject.ObjectId,-4 do
                 pointers=readPointer(pointer+k)
                 if readPointer(pointers) and inModule(pointers) then
                   local ext, opc, byt, add=splitDisassembledString(disassemble(pointers))
                   if string.find(opc,'mov') or string.find(opc,'push') or string.find(opc,'sub') then
                     UObject.funct=k printf('UObject.funct = 0x%X',UObject.funct)flag1=true break
                   end
                 end
               end
             end
           end
         end
         if flag1 then break end
       end
     end
   end

   if (not UObject.enumoffset or not UObject.enumname or not UObject.enumindex or not UObject.enummul) and string.find(name,'EInterpCurveMode') and not IgnoreList[pointer] then
     IgnoreList[pointer]=true
     print(string.format('EInterpCurveMode = %X\n',pointer))
     for j=UObject.Outer+size,0x100,4 do
       pointers=readPointer(pointer+j)
       if readPointer(pointers) and checkvalue(pointers,0x50,'CIM_Linear',1) then
         UObject.enumoffset=j
         print(string.format('EInterpCurveMode enums = %X\n',pointers))
         if UEver&gt;=7 then
           UObject.enumname=checkvalue(pointers,0x50,'CIM_Linear',1)-pointers
           UObject.enumindex=checkvalue(pointers,0x50,1,2) and checkvalue(pointers,0x50,1,2)-checkvalue(pointers,0x50,'CIM_CurveAuto',1) or 4
           for k=UObject.enumname+8,0x50,4 do
             if readInteger(pointers+k)&gt;4 and FNameStringAlgo(readInteger(pointers+k),true) then UObject.enummul=k break end
           end
         else
           UObject.enumname=0
           UObject.enumindex=4
           UObject.enummul=8
         end
       end
     end
   end

   if string.find(ObjectData.Type,'EnumProperty') then
     if not UObject.enumprop and not IgnoreList[pointer] then
       IgnoreList[pointer]=true
       print(string.format('%016X:%s %s',ObjectData.Address,ObjectData.Type,ObjectData.FullName))
       for i=UObject.Offset+4,UObject.Offset+4+0x100,4 do
         if SaveObject(readPointer(ObjectData.Address+i)) and (SaveObject(readPointer(ObjectData.Address+i)).Type=='Enum' or SaveObject(readPointer(ObjectData.Address+i)).Type=='UserDefinedEnum') then
           UObject.enumprop=i
           break
         end
       end
     end
     if UObject.enumprop then ObjectData.EnumProp = SaveObject(readPointer(ObjectData.Address+UObject.enumprop))end
   end

   return ObjectData
end

function isStructExist(name)
  for i=1,#StructList do
    if StructList[i].Name==name then return StructList[i] end
  end
  return nil
end

function SaveAndRemoveStruct()
  StructList={}
  local count=getStructureCount()
  for i=count-1,0,-1 do
    local struct=getStructure(i)
    StructList[i+1]=struct
    struct:removeFromGlobalStructureList()
  end
end

function ValidateFNamePool(pointer)
  local flag2,pointers=false
  if not pointer or pointer%4~=0 then return false end
  print(string.format('%X',pointer))
  for m=0,0x10,4 do
    if readPointer(pointer) then
      pointers=readPointer(pointer+m)
      if readPointer(pointers)then
        for n=0,2 do
          if not pointers then break end
          if readPointer(pointers) then
            for o=0,0x30,2 do
              if string.find(readString(pointers+o),'None') then
                unregisterSymbol('FNamePool') registerSymbol('FNamePool',pointer,true) flag2=true
                break
              end
            end
          end
          pointers=readPointer(pointers)
        end
      end
      if flag2 then break end
    end
    if flag2 then break end
  end
  return flag2
end

function DeleteStruct(Struct)
  local count=#StructList
  for i=1,count do
    if Struct==StructList[i] then
      Struct:Destroy()
      StructList[i]=nil
    end
    if not StructList[i] and StructList[i+1] then
      StructList[i]=StructList[i+1]
      StructList[i+1]=nil
    end
  end
end

function LoadStruct()
  for i=1,#StructList do
    StructList[i]:addToGlobalStructureList()
  end
end

function getEnumStr(fullname)
  local Address,size,EnumStr,EnumTable,list=StaticFindObjectAlgo(fullname),targetIs64Bit() and 8 or 4,'',{}
  if not Address then return nil end
  list=Address+UObject.enumoffset
  for k=0,readInteger(list+size)-1 do
    pointers=readPointer(list)+k*UObject.enummul
    offset=readBytes(pointers+UObject.enumindex,1)
    if not offset then break end
    if offset==0 then offset=k end
    propname=FNameStringAlgo(pointers+UObject.enumname)
    if string.find(propname,'::') then propname=propname:sub(string.find(propname,'::')+2,propname:len())end
    EnumStr=EnumStr..string.format('%u:%s\n',offset,propname)
    EnumTable[offset]=propname
  end
  return EnumStr,EnumTable
end

function ChildStructStart(structname,elementname)
local struct=isStructExist(structname)
if struct then
for i=0,struct.Count-1 do
if struct.Element[i].Name==elementname then return struct.Element[i].ChildStructStart end end
else return nil end
end

function sigscan(value,modulename,stopaddress)
  local ms = createMemScan()
  modulename,stopaddress=startstop(modulename,stopaddress)
  ms.firstScan(soExactValue,vtByteArray,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',true,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function findAddress(Symbol,number,Address,size)
    Address=getAddressSafe(Address)
    if not Address then return end
    if not size then size=0x200 end
	local addr,i,j,addrs={},0,1,{}
	while(i&lt;size) do
		local ext, opc, byt, add=splitDisassembledString(disassemble(Address+i))
		if ext~="" then
			if(opc:find(",")~=nil)then opc=opc:sub(opc:find(",")+1,opc:len())
			else opc=opc:sub(opc:find(" ")+1,opc:len())end
            if string.find(opc,'%[') then opc=opc:sub(string.find(opc,'%[')+1,opc:len()-1)end
            if tonumber(opc,16) and not addrs[opc] then addrs[opc]=opc addr[j]=opc j=j+1 end
        end
		if opc:find('],') then
            opc=opc:sub(opc:find("%[")+1,opc:find("]")-1)
            if tonumber(opc,16) and not addrs[opc] then addrs[opc]=opc addr[j]=opc j=j+1 end
        end
		i=i+getInstructionSize(Address+i)
	end
    if number&lt;=0 then return addr end
	unregisterSymbol(Symbol)
	registerSymbol(Symbol,getAddressSafe(addr[number]),true)
end

function checkvalue(address,size,value,typ,literal)
  local cvalue,tempvalue,value2=readBytes(address,size,true)

  if type(value)==type('') and string.find(value,'~') then
    value2=tonumber(value:sub(string.find(value,'~')+1,value:len()))
    value=tonumber(value:sub(1,string.find(value,'~')-1))
  end

  if not cvalue then return false end
  if typ==1 then
    for i=1,#cvalue,4 do
      datatable={}
      for m=1,4 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToDword(datatable)
      --print(FNameStringAlgo(tempvalue,true))
      local str=FNameStringAlgo(tempvalue,true)
      if str and (not literal and string.find(str,value) or str==value) then
        return address+i-1
      end
    end

  elseif typ==2 then
    for i=1,#cvalue,2 do
      datatable={}
      for m=1,2 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToWord(datatable)
      if tempvalue==value or (value2 and tempvalue&gt;=value and tempvalue&lt;=value2 ) then return address+i-1 end
    end
  elseif typ==4 then
    for i=1,#cvalue,4 do
      datatable={}
      for m=1,4 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToDword(datatable)
      if tempvalue==value or (value2 and tempvalue&gt;=value and tempvalue&lt;=value2 ) then return address+i-1 end
    end
  elseif typ==8 then
    for i=1,#cvalue,4 do
      datatable={}
      for m=1,8 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToQword(datatable)
      if tempvalue==value or (value2 and tempvalue&gt;=value and tempvalue&lt;=value2 ) then return address+i-1 end
    end
  end
  return nil
end

function fillstruct4bytes(Struct)
  if not getElementByOffset(Struct,0) then local e=Struct.addElement() e.Offset=0 e.Vartype=vtDword end
  Struct.beginUpdate()
  local count=Struct.Count-1
  local list,k,element1,element2,size,bytesize={},1
  for i=0,count do
    element1=Struct.Element[i]
    element2=Struct.Element[i+1]
    if element2 then
      bytesize=element1.Bytesize
      if bytesize&lt;4 then bytesize=4 end
      size=element2.Offset-element1.Offset-bytesize
      if size&gt;0 then
        if size%4&gt;0 then size=4-size%4+size end
        local start=element1.Offset
        if start%4&gt;0 then start=4-start%4+start
        else start=start+4 end
        size=size/4
        for j=0,size-1 do
          if (start+j*4)&gt;=(element1.Offset+bytesize) then
            list[k]=start+j*4
            k=k+1
          end
        end
      end
    end
  end
  for i,v in ipairs(list) do local e=Struct.addElement() e.Offset=v e.Vartype=vtPointer end
  Struct.endUpdate()
end

function UECreateStruct(LocalStruct,ArrayStruct,ObjectData,Struct,Instance,AddedOffset,AddedName)

  if AddedOffset then
    if LocalStruct[ObjectData.FullName] then copyStruct(LocalStruct[ObjectData.FullName],Struct,AddedOffset,AddedName)
    else
      local copy=createStructure(ObjectData.FullName)
      UECreateStruct(LocalStruct,ArrayStruct,ObjectData,copy,Instance)
      LocalStruct[ObjectData.FullName]=copy
      copyStruct(copy,Struct,AddedOffset,AddedName)
    end
    return
  end

  AddedOffset = AddedOffset and AddedOffset or 0
  AddedName = AddedName and AddedName or ''
  local size,MemberData,Propsize,e,f,Name,Offset,Typ=targetIs64Bit() and 8 or 4
  for i=0,10 do
    if ObjectData.Member then
      print(ObjectData.Type..' '..ObjectData.FullName)
      for j=1,#ObjectData.Member do
        MemberData=ObjectData.Member[j]
        if MemberData.Offset then
          Offset=AddedOffset+MemberData.Offset
          Propsize=MemberData.Propsize
          Name=AddedName..MemberData.Name
          Typ=MemberData.Type
          if string.find(ObjectData.Type,'UserDefinedStruct') then Name=Name:sub(1,string.find(Name,'_')-1)end
          if string.find(Typ,'StructProperty') and MemberData.Property and MemberData.Property[1] then
            UECreateStruct(LocalStruct,ArrayStruct,MemberData.Property[1],Struct,Instance,Offset,Name..'.')
            if not getElementByOffset(Struct,Offset) then e=Struct.addElement() e.Offset=Offset e.Name=Name e.Vartype=vtDword end
          else
            e=Struct.addElement()
            e.Offset=Offset
            e.Name=Name
            if string.find(Typ,'BoolProperty') and MemberData.Bit then e.ChildStructStart=MemberData.Bit end

            if Instance and string.find(Name,'RowStruct') then
              local spointer=readPointer(Instance+Offset)
              local sname,sstruct=SaveObject(spointer)
              if sname then
                print(sname.Type..' '..sname.FullName)

                if not ArrayStruct then ArrayStruct={} end
                if ArrayStruct[sname.Name] then sstruct=ArrayStruct[sname.Name]
                else
                  sstruct=createStructure(sname.Name)
                  ArrayStruct[sname.Name]=sstruct
                  UECreateStruct(LocalStruct,ArrayStruct,sname,sstruct,Instance,nil,nil)
                end
                f=Struct.addElement() f.Offset=e.Offset+8-sub f.Name='Table' f.Vartype=vtPointer
                local ssstruct=createStructure('DataTable')
                f.setChildStruct(ssstruct)
                for r=0,10 do
                  f=ssstruct.addElement() f.Offset=r*0x18 f.Name=string.format('[%u] FName',r)  f.Vartype=vtQword
                  f=ssstruct.addElement() f.Offset=r*0x18+8 f.Name=string.format('[%u] Data',r) f.Vartype=vtPointer
                  f.setChildStruct(sstruct)
                end
                fillstruct4bytes(ssstruct)

                f=Struct.addElement() f.Offset=e.Offset+0x10-sub*2 f.Name='Size' f.Vartype=vtDword
              end
            end
            if not ue4type[Typ] then e.Vartype=vtDword
            else e.Vartype=ue4type[Typ] end
            if (string.find(Typ,'ArrayProperty') or string.find(Typ,'MapProperty')) and MemberData.Property then
              f=Struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=Struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
              for m=e.Offset+0xC-sub+4,Propsize-1,4 do
                if not getElementByOffset(Struct,m) then f=Struct.addElement() f.Offset=m f.Name=string.format('%s+%X',e.Name,m) f.Vartype=vtDword end
              end
              local isMap= string.find(Typ,'MapProperty')
              if string.find(MemberData.Property[1].Type,'StructProperty') and MemberData.Property[1].Property and MemberData.Property[1].Property[1] then
                Name= MemberData.Property[1].Property[1].Name..'[]'
              else Name=MemberData.Property[1].Name..'[]'end
              if not ArrayStruct then ArrayStruct={} end
              if ArrayStruct[Name] then e.setChildStruct(ArrayStruct[Name])
              else
                local stru=createStructure(Name)
                ArrayStruct[Name]=stru
                e.setChildStruct(stru)
                local ppsize=0
                if isMap then
                  for k=1,#MemberData.Property do
                    ppsize=(MemberData.Property[k].Propsize&lt;4 and 4 or MemberData.Property[k].Propsize)+ppsize
                  end
                  ppsize=ppsize+0x8
                  --print(ppsize)
                end
                for k=1,#MemberData.Property do
                  local psize=isMap and ppsize or MemberData.Property[k].Propsize
                  --print(MemberData.Address)
                  local Offs=isMap and MemberData.Property[k].Offset and MemberData.Property[k].Offset or 0
                  for p=0,10 do
                    Offset=p*psize+Offs
                    Name=string.format('[%u] ',p)
                    Typ=MemberData.Property[k].Type
                    if string.find(MemberData.Property[k].Type,'StructProperty') then
                      UECreateStruct(LocalStruct,ArrayStruct,MemberData.Property[k].Property[1],stru,Instance,Offset,Name)
                    else
                      f=stru.addElement()
                      f.Offset=Offset
                      f.Name=Name..MemberData.Property[k].Name
                      if not ue4type[Typ] then f.Vartype=vtDword
                      else f.Vartype=ue4type[Typ]end
                    end
                  end
                end
                fillstruct4bytes(stru)
              end
            end
          end
        end
      end
    end
    if not ObjectData.Super then break end
    ObjectData=ObjectData.Super
  end

end


function ue4createstruct(FullNameOrAddress,StructName,isGlobal,isfullname,Structu,AddedOffset,AddedName,Instance,name)
  local ObjectData
  if not FullNameOrAddress then return
  elseif type(FullNameOrAddress)==type('')then
    FullNameOrAddress=StaticFindObjectAlgo(FullNameOrAddress)
    ObjectData=SaveObject(FullNameOrAddress)
  elseif type(FullNameOrAddress)==type({})then ObjectData=FullNameOrAddress
  elseif type(FullNameOrAddress)==type(0)then ObjectData=SaveObject(FullNameOrAddress) end
  --print(ObjectData.FullName)
  if not ObjectData then return end

  StructName= StructName and StructName or ObjectData.Name

  Struct=Structu and Structu or createStructure(StructName and StructName or ObjectData.Name)
  local LocalStruct,ArrayStruct,e={},{}
  Struct.beginUpdate()
  UECreateStruct(LocalStruct,ArrayStruct,ObjectData,Struct,Instance,nil,nil)
  Struct.endUpdate()
  if not getElementByOffset(Struct,0) then e=Struct.addElement() e.Offset=0 e.Name='VTable' e.Vartype=vtPointer end
  if not getElementByOffset(Struct,UObject.ObjectId) then e=Struct.addElement() e.Offset=UObject.ObjectId e.Name='ObjectIndex' e.Vartype=vtDword end
  if not getElementByOffset(Struct,UObject.Class) then e=Struct.addElement() e.Offset=UObject.Class e.Name='Class/Type' e.Vartype=vtPointer end
  if not getElementByOffset(Struct,UObject.FNameIndex) then e=Struct.addElement() e.Offset=UObject.FNameIndex e.Name='FNameIndex' e.Vartype=vtDword end
  if not getElementByOffset(Struct,UObject.Outer) then e=Struct.addElement() e.Offset=UObject.Outer e.Name='Outer' e.Vartype=vtPointer end
  if string.find(StructName,'Function') and UObject.funct then e=Struct.addElement() e.Offset=UObject.funct e.Name='Func' e.Vartype=vtPointer end
--[[
  if not Instance then fillstruct4bytes(Struct)
  else
    if not getElementByOffset(Struct,0) then Struct.autoGuess(Instance, 0, Struct.Element[0].Offset) end
    local count=Struct.Count-1
    local list,k,element1,element2,size,bytesize={},1
    for i=0,count do
      element1=Struct.Element[i]
      element2=Struct.Element[i+1]
      if element2 then
        bytesize=element1.Bytesize
        if bytesize&lt;4 then bytesize=4 end
        size=element2.Offset-element1.Offset-bytesize
        print(element1.Offset+bytesize)
        print(size)
        if size&gt;0 then
          Struct.autoGuess(Instance,element1.Offset+bytesize,size)
        end
      end
    end
  end]]
  fillstruct4bytes(Struct)
  if isGlobal then StructList[#StructList+1]=Struct end
  LoadStruct()
  return Struct

end

function AutoConfig()
  local flag1,flag2,size,val=false,false,targetIs64Bit() and 8 or 4,not UE3 and 1 or 4
  local pointer,pointers,pointerss,pointer3,Data,Data2=StaticFindObjectAlgo(not UE3 and '/Script/Engine.GameEngine' or  'Engine.Pawn')
  if not pointer then
    for i,v in pairs(ObjectTable) do if v.Name==(not UE3 and 'GameEngine' or 'Pawn') then pointer=v.Address break end end
  end
  Data=SaveObject(pointer)
  printf('%s %s = %X',Data.Type,Data.FullName,Data.Address)
  for i=UObject.Outer+size,0x100,4 do
    printf('%X',i)
    pointers=readPointer(pointer+i)
    Data=SaveObject(pointers)
    if Data then printf('%s %s = %X',Data.Type,Data.FullName,Data.Address)end
    if Data and string.find(Data.FullName,'Engine.'..(not UE3 and 'Engine' or'Actor')) and not flag1 then UObject.super=i flag1=true if not UE3 then pointer=pointers end end
    if Data and (string.find(Data.Type,'Property') or string.find(Data.Type,'Function') or string.find(Data.Type,'Enum')) and not string.find(Data.FullName,'Core') then
      printf('1. %s %s = %X',Data.Type,Data.FullName,pointers)
      for j=size,0x100,4 do
        pointerss=readPointer(pointers+j)
        printf('%X',j)
        for k=0,val do
          Data=SaveObject(pointerss)
          if not Data or (not string.find(Data.Type,'Property') and not string.find(Data.Type,'Function') and not string.find(Data.Type,'ScriptStruct') and not string.find(Data.Type,'State')) or string.find(Data.FullName,'Core') then break end
          printf('2. %X %s %s = %X',j,Data.Type,Data.FullName,pointerss)
          if k==val then UObject.nextmember=j printf('UObject.nextmember=%X',j) flag2=true break end
          pointerss=readPointer(pointerss+j)
        end
        if flag2 then break end
      end
      if flag2 then UObject.member=i printf('UObject.member=%X',i) end
      if flag1 and flag2 then break end
    end
  end
  printf('UObject.super=%X',UObject.super)
  local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
  pointerss=readPointer(UObject.member+pointer)
  for i=0,300 do
    Data=SaveObject(pointerss)
    if Data then
      print(string.format('%X:%s %s',pointerss,Data.Type,Data.FullName))
      if string.find(Data.Type,'ObjectProperty') then break end
    end
    pointerss=readPointer(UObject.nextmember+pointerss)
  end
  UObject.propsize=checkvalue(pointerss+UObject.Outer,0x100,varsize[ue4type[Data.Type]],2)-pointerss
  for i=UObject.nextmember+size,0x100,size do
    Data=SaveObject(readPointer(pointerss+i))
    if Data and string.find(Data.Type,'Class') and not string.find(Data.FullName,'Core')  then UObject.Property=i break end
  end

  pointerss=readPointer(UObject.nextmember+pointers)
  for i=0,300 do
    Data=SaveObject(pointerss)
    if Data then
      print(string.format('%X:%s %s',pointerss,Data.Type,Data.FullName))
      if string.find(Data.Type,'ObjectProperty') or string.find(Data.Type,'FloatProperty') then break end
    end
    pointerss=readPointer(UObject.nextmember+pointerss)
  end
  pointers=readPointer(UObject.nextmember+pointerss)
  for i=UObject.nextmember+size,0x100,2 do
    print(string.format('%X:',i)..readSmallInteger(pointerss+i)+varsize[ue4type[Data.Type]]..'=='..readSmallInteger(pointers+i))
    if readSmallInteger(pointerss+i)+varsize[ue4type[Data.Type]]&gt;0x10 and readSmallInteger(pointerss+i)+varsize[ue4type[Data.Type]]==readSmallInteger(pointers+i)then UObject.Offset=i print(string.format('%X',UObject.Offset)) break end
  end

  for i,v in pairs(ObjectTable) do if v.Name=='Actor' then Data=v break end end
  printf('%s %s = %X',Data.Type,Data.FullName,Data.Address)
  pointerss=readPointer(UObject.member+Data.Address)
  for i=0,100 do
    if not pointerss then break end
    Data=SaveObject(pointerss)
    if Data then
      pointer3=readPointer(UObject.nextmember+pointerss)
      print(string.format('%X:%s %s',pointerss,Data.Type,Data.FullName))
      if string.find(Data.Type,'BoolProperty') and readSmallInteger(UObject.Offset+pointerss)==readSmallInteger(UObject.Offset+pointer3) then break end
    end
    pointerss=readPointer(UObject.nextmember+pointerss)
  end
  Data=SaveObject(pointer3)
  if Data then
    print(string.format('%X:%s %s',pointer3,Data.Type,Data.FullName))
    for i=UObject.Property,0x100,1 do
      local val1,val2=readBytes(pointerss+i),readBytes(pointer3+i)
      if (val1==1 or val1%2==0) and (val2==1 or val2%2==0) and val1&lt;val2 then UObject.bitmask=i break end
    end
  end
  if not UObject.bitmask then UObject.bitmask=UObject.Property end

  print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask))

end

function getElementByOffset(struct,offset)
  for i=0,struct.Count-1 do
    if struct.Element[i].Offset==offset then return i end
  end
  return nil
end

function copyStruct(original,copy,AddedOffset,AddedName)
  if not copy then copy=createStructure(original.Name..'_copy')end
  if not AddedOffset then AddedOffset=0 end
  if not AddedName then AddedName='' end
  copy.beginUpdate()
  for i=0,original.Count-1 do
    local e=copy.addElement()
    e.Offset=original.Element[i].Offset+AddedOffset
    if original.Element[i].Name=='' then e.Name=original.Element[i].Name
    else e.Name=AddedName..original.Element[i].Name end
    e.Vartype=original.Element[i].Vartype
    e.ChildStruct=original.Element[i].ChildStruct
    e.ChildStructStart=original.Element[i].ChildStructStart
    e.Bytesize=original.Element[i].Bytesize
  end
  copy.endUpdate()
  return copy
end

function ue_structureDissectOverrideCallback(Struct, Instance)
  local name,fullname,class
  address,name,fullname,class=ue_findRealStartOfObject(Instance)

  if class then
   SaveAndRemoveStruct()
    ue4createstruct(class,nil,nil,nil,Struct,nil,nil,Instance,name)
    if Struct.Count&gt;1 then return true
    else return false end
  end

  return nil
end

function ue_structureNameLookupCallback(address)
  local name,fullname
  address,name,fullname=ue_findRealStartOfObject(address)
  if name then return name,address end
  return nil
end

function ue_SymbolLookupCallback(symbol)
  if UEMember[symbol:lower()] then return UEMember[symbol:lower()] end
  local str='Function '
  if string.find(symbol,str) then
    symbol=symbol:sub(string.find(symbol,str)+str:len(),symbol:len())
    local pointer=StaticFindObjectAlgo(symbol)
    if pointer then return readPointer(pointer+UObject.funct)end
  end
  return nil
end

function ue_findRealStartOfObject(address)
  local ObjectData,Membersize
  ObjectData=SaveObject(address)
  if ObjectData then return ObjectData.Address,ObjectData.Class.Name,ObjectData.Class.FullName,ObjectData.Class or nil end

  for i=1,HighestObjectID+10 do
    if ObjectTable[i] and ObjectTable[i].Class then
      Membersize = (ObjectTable[i].Class.Membersize and ObjectTable[i].Class.Membersize&gt;0x100 and ObjectTable[i].Class.Membersize&lt;0x5000) and ObjectTable[i].Class.Membersize or 0x500
      if address&gt;=ObjectTable[i].Address and address&lt;=ObjectTable[i].Address+Membersize then
        ObjectData=ObjectTable[i]
        return ObjectData.Address,ObjectData.Class.Name,ObjectData.Class.FullName,ObjectData.Class
      end
    end
  end
  return address
end

function findOpcodes(address,opcode,size)
  if not size then size=0x50 end
  address=getAddressSafe(address)
  if not address then return nil end
  local addr={}
  local i=0
  local j=1
  while(i&lt;size) do
    local ext, opc, byt, add=splitDisassembledString(disassemble(address+i))
    if string.find(opc,opcode) then
      addr[j]=address+i
      j=j+1
    end
    i=i+getInstructionSize(address+i)
  end
  return addr
end

function findOpcode(address,opcode,size)
  if not size then size=0x50 end
  address=getAddressSafe(address)
  if not address then return nil end
  local i=0
  while(i&lt;size) do
    local ext, opc, byt, add=splitDisassembledString(disassemble(address+i))
    if string.find(opc,opcode) then
      return address+i
    end
    i=i+getInstructionSize(address+i)
  end
  return nil
end

function findLastCall(address,size)
  if not address then return end
  if not size then size=0x1000 end
  local result=findOpcode(address,'ret',size)
  if not result then print(address..' cant find ret?') return nil end
  result=result-getAddress(address)
  result=findOpcodes(address,'call ',result)
  local ext, opc, byt, add=splitDisassembledString(disassemble(result[#result]))
  opc=opc:gsub('call ','')
  return opc
end

function getOffsets(address,size)
  if not size then size=0x1000 end
  local result=findOpcodes(address,'+',size)
  for i=1,#result do
    local ext, opc, byt, add=splitDisassembledString(disassemble(result[i]))
    result[i]=opc:sub(opc:find('+')+1,opc:len()-1)
  end
  return result
end


function followjmp(address,size)
  if not size then size=0x1000 end
  local result=findOpcode(address,'jmp ',size)
  if not result then print(address..' cant find jmp?') return nil end
  local ext, opc, byt, add=splitDisassembledString(disassemble(result))
  opc=opc:gsub('jmp ','')
  return opc
end

function followcall(address,size)
  if not size then size=0x1000 end
  local result=findOpcode(address,'call ',size)
  if not result then print(address..' cant find call?') return nil end
  local ext, opc, byt, add=splitDisassembledString(disassemble(result))
  opc=opc:gsub('call ','')
  return opc
end

function ProcessEvent(instance,ufunction,params)
local str=([[
label(newmem)
label(returnhere)
label(%s)
registersymbol(%s)
label(ProcessEventFlag)
registersymbol(ProcessEventFlag)
label(code)
label(temp)

%s:
newmem:
mov rax,ProcessEventFlag
cmp byte ptr[rax],01
je short @f
mov byte ptr[rax],01
mov rax,temp
pop [rax]
mov [rax+8],rcx
mov [rax+20],rsp
ba2nana
mov rax,code
push rax

@@:
%s
jmp returnhere
code:
mov rcx,ProcessEventFlag
mov byte ptr[rcx+1],01
mov rcx,temp
mov rsp,[rcx+20]
pop rcx
pop rcx
mov rcx,temp
ba3nana
push [rcx]
mov rcx,[rcx+8]
jmp newmem
%s:
db %X %s
ProcessEventFlag:
dq 0
temp:
dq 0 0 0 0 0 0
%X:
jmp newmem
]]):gsub('ba2nana',( not UE3 and (targetIs64Bit() and string.format(([[
mov [rax+10],rdx
mov [rax+18],r8
mov rcx,%X
mov rdx,%X
mov r8,%X
]]),instance,ufunction,params) or string.format(([[
pop [rax+10]
pop [rax+18]
mov rcx,%X
mov rdx,%X
mov rax,%X
push rdx
push rax
]]),instance,ufunction,params))or string.format(([[
pop [rax+10]
pop [rax+18]
mov rcx,%X
mov rdx,%X
%s
push rdx

]]),instance,ufunction,params))):gsub('ba3nana',(targetIs64Bit() and ([[
mov rdx,[rcx+10]
mov r8,[rcx+18]
]])or([[
push [rcx+18]
push [rcx+10]
]])))

enablescript('ProcessEvent_alloc','ProcessEvent_save','UObject::ProcessEvent',str)

for i=0,1000 do
  if not readInteger('ProcessEventFlag+1') or readInteger('ProcessEventFlag+1')==1 then break end
  sleep(1)
end


enablescript('ProcessEvent_alloc','ProcessEvent_save','UObject::ProcessEvent',[[
%X:
readmem(%s+1,%u)
]],true)
unregisterSymbol('ProcessEventFlag')
end

function ProcessEventCall(method,param)
param= param or ''
local str=([[
label(newmem)
label(returnhere)
label(%s)
registersymbol(%s)
label(ProcessEventCallFlag)
registersymbol(ProcessEventCallFlag)
label(temp)

%s:
newmem:
mov rax,ProcessEventCallFlag
cmp byte ptr[rax],01
je long @f
mov byte ptr[rax],01
mov rax,temp
mov [rax+8],rcx
mov [rax+10],rdx
mov [rax+18],r8
mov [rax+20],rsi
mov [rax+28],rsp
sub rsp,50
banana
call rax

mov rcx,temp
mov rdx,[rcx+10]
mov r8,[rcx+18]
mov rsi,[rcx+20]
mov rsp,[rcx+28]
mov rcx,[rcx+8]
push rcx
mov rcx,ProcessEventCallFlag
mov [rcx+8],rax
mov byte ptr[rcx+1],01
pop rcx
@@:
%s
jmp returnhere
%s:
db %X %s
ProcessEventCallFlag:
dq 0 0 0
temp:
dq 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
%X:
jmp newmem
]]):gsub('banana',string.format('%s\nmov rax,%X\n',param,method)):gsub('r8',( targetIs64Bit() and 'r8' or 'rdi'))

enablescript('ProcessEventCall_alloc','ProcessEventCall_save',indexdism('UObject::ProcessEvent')[(targetIs64Bit() and 9 or 11)].add,str)

for i=0,1000 do
  if not readInteger('ProcessEventCallFlag+1') or readInteger('ProcessEventCallFlag+1')==1 then break end
  sleep(1)
end
local result=readPointer('ProcessEventCallFlag+8')


enablescript('ProcessEventCall_alloc','ProcessEventCall_save',indexdism('UObject::ProcessEvent')[(targetIs64Bit() and 9 or 11)].add,[[
%X:
readmem(%s+1,%u)
]],true)
unregisterSymbol('ProcessEventCallFlag')

return result
end

function checkFuncReg(address)
if type(address)==type(0) then address=string.format('%X',address)end
local str=([[
label(newmem)
label(returnhere)
label(%s)
registersymbol(%s)
label(CheckFunctionRegFlag)
registersymbol(CheckFunctionRegFlag)
label(temp)
%s:
newmem:
push rax
mov rax,temp
pop [rax]
mov rax,CheckFunctionRegFlag
cmp byte ptr[rax+1],01
je short @f
mov byte ptr[rax+1],01
banana
@@:
mov rax,temp
push [rax]
mov byte ptr[rax],01
pop rax
%s
jmp returnhere
temp:
dq 0 0
%s:
db %X %s
CheckFunctionRegFlag:
dq 0 0 0 0 0 0 0
%X:
jmp newmem
]]):gsub('banana', targetIs64Bit() and ([[
mov [rax+8],rcx
mov [rax+10],rdx
mov [rax+18],r8
mov [rax+20],r9
]]) or [[
mov [rax+8],rcx
pop [rax+4]
pop [rax+10]
pop [rax+18]
pop [rax+20]
push [rax+20]
push [rax+18]
push [rax+10]
push [rax+4]
]])
enablescript('CheckFunctionReg_alloc','CheckFunctionReg_save',address,str)

for i=0,10 do
  if not readInteger('CheckFunctionRegFlag') or readInteger('CheckFunctionRegFlag')==1 then break end
  sleep(1)
end

local result={readPointer('CheckFunctionRegFlag+8'),readPointer('CheckFunctionRegFlag+10'),readPointer('CheckFunctionRegFlag+18'),readPointer('CheckFunctionRegFlag+20')}
enablescript('CheckFunctionReg_alloc','CheckFunctionReg_save',address,[[
%X:
readmem(%s+1,%u)
]],true)
unregisterSymbol('CheckFunctionRegFlag')
return result
end

function indexdism(Address)
  Address=getAddressSafe(Address)
  if not Address then return nil end
  size=0x100
  local addr={}
  local i=0
  local j=1
  while(i&lt;size) do
    addr[j]={}
    addr[j].ext, addr[j].opc, addr[j].byt, addr[j].add=splitDisassembledString(disassemble(Address+i))
    j=j+1
	i=i+getInstructionSize(Address+i)
  end
  return addr
end

function startstop(modulename,stopaddress)
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  if type(modulename)==type(0) then modulename=string.format('%X',modulename)
  elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
  if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
    stopaddress=getNameFromAddress(getAddress(modulename),true,false)
    if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
	if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
    modulename=getAddress([["]]..stopaddress..[["]])
	stopaddress=modulename+getModuleSize(stopaddress)
    modulename=string.format('%X',modulename)
  end
  if type(stopaddress)==type(0) then stopaddress=string.format('%X',stopaddress)end
  return modulename,stopaddress
end

function groupscan(value,modulename,stopaddress)
  local ms = createMemScan()
  modulename,stopaddress=startstop(modulename,stopaddress)
  ms.firstScan(soExactValue,vtGrouped,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress,value2)
  local ms = createMemScan()
  modulename,stopaddress=startstop(modulename,stopaddress)
  print(modulename..'~'..stopaddress)
  if value2 then ms.firstScan(soValueBetween,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  else ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)end
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function stringscan(value,modulename,stopaddress,isUnicode)
  local ms = createMemScan()
  modulename,stopaddress=startstop(modulename,stopaddress)
  ms.firstScan(soExactValue,vtString,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,isUnicode,true)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function StructAddToListSymbol(StructName,StartOffset,StopOffset,BaseAddress,OffsetOnly)
  if not StartOffset then StartOffset=0 end
  if not StopOffset then StopOffset=0xFFFFFF end
  local structCount=getStructureCount()
  local struct
  for i=0,structCount-1 do
    local stru=getStructure(i)
    if stru.Name==StructName then struct=stru break end
  end
  if struct then
    for i=0,struct.Count-1 do
      local e=struct.Element[i]
      if e.Offset&gt;=StartOffset and e.Offset&lt;=StopOffset then
        local rec=getAddressList().createMemoryRecord()
        rec.setDescription(e.Name)
        if OffsetOnly then
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.Offset[0]=e.Offset
          else rec.setAddress(string.format('+%X',e.Offset))end
        else
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.OffsetText[0]=StructName..'.'..e.Name
          else rec.setAddress(string.format('+%s.%s',StructName,e.Name))end
        end
        rec.Type=e.Vartype
      end
    end
  end
end

function getInsForJump(address,registername,destination,allocsize,SharedMemoryName,num)
  address = getAddressSafe(address)
  if not address then error('getInsForJump address nil') return end
  if not allocsize then allocsize=4096 end
  destination=getAddressSafe(destination)
  while not destination do
    destination =  allocateMemory((not SharedMemoryName and allocsize or SharedMemoryName),address)
  end
  size = not num and ((address+5-destination&gt;0x7FFFFFFF) and 14 or 5) or 100
  num = not num and 10 or num
  if registername then
	unregisterSymbol(registername)
	registerSymbol(registername,destination,true)
  else deAlloc(destination) end
  local opcodes = {}
  local i = 0
  while i&lt;size and #opcodes&lt;num do
    local ext, opc=splitDisassembledString(disassemble(address+i))
    opcodes[#opcodes+1] = opc
    i=i+getInstructionSize(address+i)
  end
  local copy = table.concat(opcodes,'\r\n')
  local readAsTable = true
  local byt = readBytes(address,i,readAsTable)
  for j=1,#byt do byt[j] = ('%02X'):format(byt[j]) end
  local bytes = table.concat(byt, ' ')
  return i,copy,bytes,size,destination
end

function AAscript(script)
  local success,erro=autoAssembleCheck(script)
  if not success then
    print('\n'..erro..'\n')
    local scriptstr=createStringlist()scriptstr.Text=script
    for j=0,scriptstr.Count-1 do print(string.format('%u\t%s',j+1,scriptstr[j])) end
    error('autoAssemble failed')
  end
  autoAssemble(script)
end

function enablescript(name,registername,addressname,script,disable)
    local address=getAddress(addressname)
    if disable then script=(script):format(address,registername,readBytes(registername,1))
    else
        local i,copy,bytes,size =getInsForJump(address,name)
        script=(script):format(registername, registername, name, copy, registername, i, bytes, address)..string.rep('nop\n',i-size)..'returnhere:'
    end
    local success,erro=autoAssembleCheck(script)
    if not success then print('\n'..erro..'\n')local scriptstr=createStringlist()scriptstr.Text=script for j=0,scriptstr.Count-1 do print(string.format('%u\t%s',j+1,scriptstr[j])) end
    if not disable then deAlloc(name)unregisterSymbol(name)end error(name..' autoAssemble failed')end
    autoAssemble(script)
    if disable then deAlloc(name)unregisterSymbol(name)unregisterSymbol(registername)end
end

function toStr(rec)
  local tec,str,list=rec,'',{}
  while(true)do
    if not tec or not tec.Address then break end
    list[#list+1]=tec
    if tec.Address:sub(1,1)~='+' then break end
    tec=tec.Parent
  end
  for i=#list,1,-1 do
    str=string.format('%s%s',str,list[i].Address)
    for j=list[i].OffsetCount-1,0,-1 do
      str=string.format('[%s]+%s',str,list[i].OffsetText[j])
    end
  end
  if rec and rec.Address then
    rec.DontSave=false
    rec.Address=str
    rec.OffsetCount=0
  end
end

function toStrChildren(rec)
  for i=0,rec.Count-1 do
    toStrChildren(rec.Child[i])
  end
  toStr(rec)
end

function toStrSelectedMemrec()
  for i,v in pairs(getAddressList().getSelectedRecords()) do
    toStrChildren(v)
  end
end

function cycleFullCompact(sender,force)
  local state = not(compactmenuitem.Caption == 'Compact View Mode')
  if force~=nil then state = not force end
  compactmenuitem.Caption = state and 'Compact View Mode' or 'Full View Mode'
  getMainForm().Splitter1.Visible = state
  getMainForm().Panel4.Visible = state
  getMainForm().Panel5.Visible = state
end

function addCompactMenu()
  if compactmenualreadyexists then return end
  local parent = getMainForm().Menu.Items
  compactmenuitem = createMenuItem(parent)
  parent.add(compactmenuitem)
  compactmenuitem.Caption = 'Compact View Mode'
  compactmenuitem.OnClick = cycleFullCompact
  compactmenualreadyexists = 'yes'
end

addCompactMenu()
--cycleFullCompact(nil,true)

local list,str,func=getAddressList()
for i=0,list.Count-1 do
  if list[i].Script and list[i].Script~='' then
    --print(list[i].Description)
    str=list[i].Script
    for i=0,1000 do
      if not string.find(str,'function ') then break
      else
        str=str:sub(string.find(str,'function ')+9,str:len())
        if str:sub(1,1)~="'" then
          func=str:sub(1,string.find(str,'%(')-1)
          unregisterLuaFunctionHighlight(func)
          registerLuaFunctionHighlight(func)
          --print(func)
        end
      end
    end
  end
end
if not FuncSizeList then FuncSizeList={}end
if syntaxcheck then return end

[ENABLE]
if not process or not enumModules()[1] then print('Error: No process selected...') error('process is nil') end
if readPointer('Core.UObject::GObjObjects')then unregisterSymbol('GUObjectArray') registerSymbol('GUObjectArray','Core.UObject::GObjObjects',true) end
if readPointer('Core.FName::Names')then unregisterSymbol('FNamePool') registerSymbol('FNamePool','Core.FName::Names',true) end
starttime=os.clock()

if string.find(process,'MassEffect') then
  isMassEffect=true

  local result2,result=sigscan('C0 CA 45 80 00 00 00 00 00 00 00 00 4E 6F 6E 65 00',process)
  for i=1,#result2 do
    result=pointerscan(getAddress(result2[i]),process)
    for j=1,#result do
      stringoffset=0xC
      print(result[j])
      unregisterSymbol('FNamePool') registerSymbol('FNamePool',result[j],true)
    end
  end

  UE4ver=ue4versioncheck()
  local rec=getAddressList().getMemoryRecordByDescription('Object scanner (region)')
  if rec and not rec.Active then
    rec.Active=true
    while rec.AsyncProcessing do sleep(100) end
  end
  else isMassEffect=nil
end

if not UEMember or type(UEMember)~=type({}) then UEMember={}end

if not UE4ver then UE4ver=ue4versioncheck() end

local flag1,flag2,flag3,address,result1,result2,pointer,pointers,pointer1,pointer2,pointer3,rec=false,false
if not readPointer('GUObjectArray') then

    local ObjectAOB={'44 8B * * * 48 8D 05 * * * * * * * * * 48 89 71 10'
    ,'40 53 48 83 EC 20 48 8B D9 48 85 D2 74 * 8B'
    ,'4C 8B 05 * * * * 45 3B 88'
    ,'4C 8B 44 24 60 8B 44 24 78 * * * 48 8D','8B 44 24 04 56 8B F1 85 C0 74 17 8B 40 08'
    ,'8B 44 24 04 56 8B F1 85 C0 74 17 8B 40 08'
    ,'8B 15 * * * * 8B 04 82 85'
    ,'56 48 83 * * 48 89 * * * 48 89 * 48 8D'
    }
    for i=1,#ObjectAOB do
      result1=sigscan(ObjectAOB[i],process)
      for j=1,#result1 do
        print(i..':i'..':'..result1[j])
        result2=findAddress('GUObjectArray',0,result1[j],0x50)
        for k=1,#result2 do
          pointer=getAddress(result2[k])-0x70
          print(i..':j'..':'..result2[k])
          for m=0,0x100,4 do
            if readPointer(readPointer(readPointer(pointer+m))) then
              if m&gt;0x50 then unregisterSymbol('GUObjectArray') registerSymbol('GUObjectArray',result2[k],true)
              else unregisterSymbol('GUObjectArray') registerSymbol('GUObjectArray',result2[k]..'-68',true) end
              flag1=true break
            end
          end
          if flag1 then break end
        end
        if flag1 then break end
      end
      if flag1 then break end
    end
    if flag1 then
      pointer1=getAddress('GUObjectArray')
      for i=pointer1-0x50,pointer1+0x200,4 do
        flag3=nil
        if readPointer(readPointer(readPointer(readPointer(i))))then
          pointer=i
          for n=0,2 do
            for o=4,(UE3 and size or 8*4),4 do
            flag3=nil
            for k=0,10*o,o do
              pointers=readPointer(pointer+k)
              if not readPointer(readPointer(pointers))
              or not readPointer(readPointer(readPointer(pointers)))
              or not inModule(readPointer(readPointer(pointers)))
              or not checkvalue(pointers,0x50,k/o,2) then break end
              if k==(10*o)then flag3=true print(string.format('%X %X',i,o)) unregisterSymbol('GUObjectArray') registerSymbol('GUObjectArray',i,true) NOGUObjectsize=(n==0 and true or nil) break end
            end
            if flag3 then break end
            end
            if flag3 then break end
            pointer=readPointer(pointer)
          end
        end
        if flag3 then break end
      end
      if not flag3 then print('GUObjectArray not found, running scanner...') flag1=nil
      else print(string.format('GUObjectArray = %X',getAddress('GUObjectArray')))end

    else print('GUObjectArray not found, running scanner...') end
    flag1 = not flag1

    if not flag1 and ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
      if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
      elseif readInteger('GUObjectArray+14')==0 then UE4ver=9
      else UE4ver=20 end
    end

end
if not readPointer('FNamePool') then
    if string.find(process,'StateOfDecay2')then
      findAddress('FNamePool',1,sigscan('48 8D * * * * * 8B * * 85 * 74 * 8D',process)[1])
      findAddress('FNamePool2',3,sigscan('48 8D * * * * * 8B * * 85 * 74 * 8D',process)[1])
      FNamePool=getAddress('FNamePool')
      FNamePool2=getAddress('FNamePool2')
      flag2=true
    end

    local NamePoolAOB={'4C 8D 05 * * * * EB 16 48 8D 0D * * * * E8'
    ,'48 8D 0D *  *  *  *  E8 *  *  *  *  *  8B *  C6'
    ,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8'
    ,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8'
    ,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20'
    ,'33 F6 89 35 * * * * 8B C6 5E'
    ,'8B 07 8B 0D * * * * 8B 04 81'
    }
    for i=(UE4ver&gt;=23 or ue4versioncheck()&lt;2) and 1 or 3,#NamePoolAOB do
      result1=sigscan(NamePoolAOB[i],process)
      for j=1,#result1 do
        print(i..':i'..':'..result1[j])
        result2=findAddress('FNamePool',0,result1[j],0x50)
        for k=1,#result2 do
          print(i..':j'..':'..result2[k])
          pointer=getAddress(result2[k])
          flag2=ValidateFNamePool(pointer)
          if flag2 then UE4ver=ue4versioncheck()==0 and (i&gt;2 and 18 or 23) or UE4ver break end
        end
        if flag2 then break end
      end
      if flag2 then break end
    end
    if flag2 then print(string.format('FNamePool = %X',getAddress('FNamePool')))
    else print('FNamePool not found, running scanner...') end
    flag2 = not flag2

end

if flag2 then
  local FNamePoolScanner={'FNamePool scanner V4 (BatmanAk)','FNamePool scanner V2 (Generic)','FNamePool scanner V3 (Unicode)'}
  unregisterSymbol('FNamePool')
  UE4ver=ue4versioncheck()
  for i=(string.find(process:lower(),'batmanak') and 1 or 2),#FNamePoolScanner do
    rec=getAddressList().getMemoryRecordByDescription(FNamePoolScanner[i])
    if rec and not rec.Active then
      rec.Active=true
      while rec.AsyncProcessing do sleep(100) end
    end
    if readPointer('FNamePool') then break end
  end
  if not readPointer('FNamePool') then error('FNamePool not found!')end
end

if flag1 then
  local ObjectScanner={'Object scanner (region)','Object scanner','UE3 Namepool &amp; ObjectArray scanner (using string reference)'}
  unregisterSymbol('GUObjectArray')
  print(UE4ver)
  for i=1,#ObjectScanner do
    rec=getAddressList().getMemoryRecordByDescription(ObjectScanner[i])
    if rec and not rec.Active then
      rec.Active=true
      while rec.AsyncProcessing do sleep(100) end
    end
    if readPointer('GUObjectArray') then break end
  end
  if not readPointer('GUObjectArray') then error('GUObjectArray not found!')end
end

print('AOBScan done : '..os.clock()-starttime)

ue4parsetable()

if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

ue4config()
ue4parsetable()
if UE4ver==23 and ue4versioncheck()==0 then BasicEnumObject() end
AutoConfig()

--[[
if ue4versioncheck()==0 and UE4ver&gt;=25 then
  ue4config()
  ue4parsetable()
  BasicEnumObject()
end]]

print('Table parsing done : '..os.clock()-starttime)

rec=getAddressList().getMemoryRecordByDescription('UEMemberStr(DoNotTouch!)')
if rec then rec.Active=true end

print('UE ver: '..UE4ver)
BasicEnumObject()



rec=getAddressList().getMemoryRecordByDescription('Get GEngine')
  if rec then
  rec.Active=true
  while rec.AsyncProcessing do sleep(100) end
end
createThread(registerFuncAlgo)
createThread(registerMemberAlgo)
print('All done : '..os.clock()-starttime..'\n')
if not ue_SymbolLookupCallbackID then
  ue_SymbolLookupCallbackID=registerSymbolLookupCallback(ue_SymbolLookupCallback,slNotSymbol)
end
--registerFuncAlgo()

GetLuaEngine().close()

if not toStrSelectedMemrecHotkey then toStrSelectedMemrecHotkey=createHotkey('toStrSelectedMemrec', VK_LCONTROL,VK_N)end
[DISABLE]
--cycleFullCompact(nil,false)
unregisterSymbolLookupCallback(ue_SymbolLookupCallbackID)
ue_SymbolLookupCallbackID=nil
---toStrSelectedMemrecHotkey:Destroy()
</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>26076</ID>
          <Description>"Enable UE Structure Lookup "</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
if not ue_structureDissectOverrideCallbackID then
  ue_structureDissectOverrideCallbackID=registerStructureDissectOverride(ue_structureDissectOverrideCallback)
end
if not ue_structureNameLookupCallbackID then
  ue_structureNameLookupCallbackID=registerStructureNameLookup(ue_structureNameLookupCallback)
end

[DISABLE]
unregisterStructureDissectOverride(ue_structureDissectOverrideCallbackID)
unregisterStructureNameLookup(ue_structureNameLookupCallbackID)
ue_structureDissectOverrideCallbackID=nil
ue_structureNameLookupCallbackID=nil
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26116</ID>
          <Description>"Refresh ObjectList"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
BasicEnumObject()

[DISABLE]
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26117</ID>
          <Description>"Re-register Fields/Members 's Symbols"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
registerMemberAlgo()

[DISABLE]
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26115</ID>
          <Description>"UE Object Dumper Algo"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

starttime=os.clock()

totalobject=0
local Path = 'C:\\Users\\'..os.getenv('USERNAME')..'\\Desktop\\'
local filename= string.format('[%s] ObjectsDump.txt',process)
local file,err = io.open(Path..filename, 'w')
assert(file,err)
print(Path..filename)
file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
local size,sizes,pointer,datatable,pointers,propname,offset,list,str,strid,name,objid,ObjectData=targetIs64Bit() and 8 or 4,HighestObjectID+10
for i=1,sizes do
  if ObjectTable[i] then
    ObjectData=ObjectTable[i]
    totalobject=totalobject+1
    str=string.format('%016X',ObjectData.Address)
    strid=string.format('%08u',ObjectData.ObjectId)
    name= ObjectData.Bit and string.format('%s %08X %s',ObjectData.Type,ObjectData.Bit,ObjectData.FullName)or string.format('%s %s',ObjectData.Type,ObjectData.FullName)
    if ObjectData.Offset then
      strid=string.format('%8X',ObjectData.Offset)
    elseif ObjectData.Super and ObjectData.Super.Name~='Object' then
      name=string.format('%s ~ %s %s',name,ObjectData.Super.Type,ObjectData.Super.FullName)
    end
    if ObjectData.Property and #ObjectData.Property==1 then
      name=string.format('%s ~ %s %s',name,ObjectData.Property[1].Type,ObjectData.Property[1].FullName)
    end
    if ObjectData.EnumProp then
      name=string.format('%s ~ %s %s',name,ObjectData.EnumProp.Type,ObjectData.EnumProp.FullName)
    end

    file:write(string.format('[%s] %s %s\n',strid,str,name))

    if ObjectData.Property and #ObjectData.Property==2 then
      for j=1,2 do
        name=string.format('%s %s',ObjectData.Property[j].Type,ObjectData.Property[j].FullName)
        if ObjectData.Property[j].Property and ObjectData.Property[j].Property[1] then
          name=string.format('%s ~ %s %s',name,ObjectData.Property[j].Property[1].Type,ObjectData.Property[j].Property[1].FullName)
        end
        if ObjectData.Property[j].EnumProp then
          name=string.format('%s ~ %s %s',name,ObjectData.Property[j].EnumProp.Type,ObjectData.Property[j].EnumProp.FullName)
        end
        file:write(string.format('[%8X] %016X %s\n',readInteger(ObjectData.Property[j].Address+UObject.Offset),ObjectData.Property[j].Address,name))
      end
    end

    if UObject.enumoffset and UObject.enummul and UObject.enumindex and UObject.enumname then
    if ObjectData.Type=='UserDefinedEnum' or ObjectData.Type=='Enum' then
      list=ObjectData.Address+UObject.enumoffset
      for k=0,readInteger(list+size)-1 do
        pointers=readPointer(list)+k*UObject.enummul
        offset=readBytes(pointers+UObject.enumindex,1)
        if not offset then break end
        if offset==0 then offset=k end
        propname=FNameStringAlgo(pointers+UObject.enumname)
        strid=string.format('%8X',offset)
        str=string.format('%016X',pointers)
        file:write(string.format('[%s] %s %s\n',strid,str,propname))
      end
    end
    end

    if ObjectData.Member and UE4ver&gt;=25 then
      for m=1,#ObjectData.Member do
        if not string.find(ObjectData.Member[m].Type,'Function')then

        totalobject=totalobject+1

        str=string.format('%016X',ObjectData.Member[m].Address)
        strid=string.format('%08u',ObjectData.Member[m].ObjectId)
        name= ObjectData.Member[m].Bit and string.format('%s %08X %s',ObjectData.Member[m].Type,ObjectData.Member[m].Bit,ObjectData.Member[m].FullName)or string.format('%s %s',ObjectData.Member[m].Type,ObjectData.Member[m].FullName)
        if ObjectData.Member[m].Offset then
          strid=string.format('%8X',ObjectData.Member[m].Offset)
        end
        if ObjectData.Member[m].Property and #ObjectData.Member[m].Property==1 then
          name=string.format('%s ~ %s %s',name,ObjectData.Member[m].Property[1].Type,ObjectData.Member[m].Property[1].FullName)
        end
        if ObjectData.Member[m].EnumProp then
          name=string.format('%s ~ %s %s',name,ObjectData.Member[m].EnumProp.Type,ObjectData.Member[m].EnumProp.FullName)
        end

        file:write(string.format('[%s] %s %s\n',strid,str,name))

        if ObjectData.Member[m].Property and #ObjectData.Member[m].Property==2 then
        for j=1,2 do
          name=string.format('%s %s',ObjectData.Member[m].Property[j].Type,ObjectData.Member[m].Property[j].FullName)
          if ObjectData.Member[m].Property[j].Property and ObjectData.Member[m].Property[j].Property[1] then
            name=string.format('%s ~ %s %s',name,ObjectData.Member[m].Property[j].Property[1].Type,ObjectData.Member[m].Property[j].Property[1].FullName)
          end
          if ObjectData.Member[m].Property[j].EnumProp then
            name=string.format('%s ~ %s %s',name,ObjectData.Member[m].Property[j].EnumProp.Type,ObjectData.Member[m].Property[j].EnumProp.FullName)
          end
          file:write(string.format('[%8X] %016X %s\n',readInteger(ObjectData.Member[m].Property[j].Address+UObject.Offset),ObjectData.Member[m].Property[j].Address,name))
        end
        end
    end



      end
    end

  end
end
file:close()
print(string.format('\nA Total of %u objects has been dumped in %.3f seconds',totalobject,os.clock()-starttime))

shellExecute(Path..filename)

[DISABLE]

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26209</ID>
          <Description>"UE Object Dumper All Algo"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
function BasicObjectdump(this,pointerss,start,stop)
  local size,pointer,datatable,pointers,propname,offset,list,str,strid,name,objid,ObjectData,pointersss=targetIs64Bit() and 8 or 4
  for j=start,stop do
    pointersss=readPointer(pointerss+j*UObjectMul)
    if not readPointer(pointersss)then break end
    ObjectData=SaveObject(pointersss)
    if ObjectData then

--for i=1,sizes do
--  if ObjectTable[i] then
    --ObjectData=ObjectTable[i]
    totalobject=totalobject+1
    str=string.format('%016X',ObjectData.Address)
    strid=string.format('%08u',ObjectData.ObjectId)
    name= ObjectData.Bit and string.format('%s %08X %s',ObjectData.Type,ObjectData.Bit,ObjectData.FullName)or string.format('%s %s',ObjectData.Type,ObjectData.FullName)
    if ObjectData.Offset then
      strid=string.format('%8X',ObjectData.Offset)
    elseif ObjectData.Super and ObjectData.Super.Name~='Object' then
      name=string.format('%s ~ %s %s',name,ObjectData.Super.Type,ObjectData.Super.FullName)
    end
    if ObjectData.Property and #ObjectData.Property==1 then
      name=string.format('%s ~ %s %s',name,ObjectData.Property[1].Type,ObjectData.Property[1].FullName)
    end
    if ObjectData.EnumProp then
      name=string.format('%s ~ %s %s',name,ObjectData.EnumProp.Type,ObjectData.EnumProp.FullName)
    end

    file:write(string.format('[%s] %s %s\n',strid,str,name))

    if ObjectData.Property and #ObjectData.Property==2 then
      for j=1,2 do
        name=string.format('%s %s',ObjectData.Property[j].Type,ObjectData.Property[j].FullName)
        if ObjectData.Property[j].Property and ObjectData.Property[j].Property[1] then
          name=string.format('%s ~ %s %s',name,ObjectData.Property[j].Property[1].Type,ObjectData.Property[j].Property[1].FullName)
        end
        if ObjectData.Property[j].EnumProp then
          name=string.format('%s ~ %s %s',name,ObjectData.Property[j].EnumProp.Type,ObjectData.Property[j].EnumProp.FullName)
        end
        file:write(string.format('[%8X] %016X %s\n',readInteger(ObjectData.Property[j].Address+UObject.Offset),ObjectData.Property[j].Address,name))
      end
    end

    if UObject.enumoffset and UObject.enummul and UObject.enumindex and UObject.enumname then
    if ObjectData.Type=='UserDefinedEnum' or ObjectData.Type=='Enum' then
      list=ObjectData.Address+UObject.enumoffset
      for k=0,readInteger(list+size)-1 do
        pointers=readPointer(list)+k*UObject.enummul
        offset=readBytes(pointers+UObject.enumindex,1)
        if not offset then break end
        if offset==0 then offset=k end
        propname=FNameStringAlgo(pointers+UObject.enumname)
        strid=string.format('%8X',offset)
        str=string.format('%016X',pointers)
        file:write(string.format('[%s] %s %s\n',strid,str,propname))
      end
    end
    end

    if ObjectData.Member and UE4ver&gt;=25 then
      for m=1,#ObjectData.Member do
        if not string.find(ObjectData.Member[m].Type,'Function')then

        totalobject=totalobject+1

        str=string.format('%016X',ObjectData.Member[m].Address)
        strid=string.format('%08u',ObjectData.Member[m].ObjectId)
        name= ObjectData.Member[m].Bit and string.format('%s %08X %s',ObjectData.Member[m].Type,ObjectData.Member[m].Bit,ObjectData.Member[m].FullName)or string.format('%s %s',ObjectData.Member[m].Type,ObjectData.Member[m].FullName)
        if ObjectData.Member[m].Offset then
          strid=string.format('%8X',ObjectData.Member[m].Offset)
        end
        if ObjectData.Member[m].Property and #ObjectData.Member[m].Property==1 then
          name=string.format('%s ~ %s %s',name,ObjectData.Member[m].Property[1].Type,ObjectData.Member[m].Property[1].FullName)
        end
        if ObjectData.Member[m].EnumProp then
          name=string.format('%s ~ %s %s',name,ObjectData.Member[m].EnumProp.Type,ObjectData.Member[m].EnumProp.FullName)
        end

        file:write(string.format('[%s] %s %s\n',strid,str,name))

        if ObjectData.Member[m].Property and #ObjectData.Member[m].Property==2 then
        for j=1,2 do
          name=string.format('%s %s',ObjectData.Member[m].Property[j].Type,ObjectData.Member[m].Property[j].FullName)
          if ObjectData.Member[m].Property[j].Property and ObjectData.Member[m].Property[j].Property[1] then
            name=string.format('%s ~ %s %s',name,ObjectData.Member[m].Property[j].Property[1].Type,ObjectData.Member[m].Property[j].Property[1].FullName)
          end
          if ObjectData.Member[m].Property[j].EnumProp then
            name=string.format('%s ~ %s %s',name,ObjectData.Member[m].Property[j].EnumProp.Type,ObjectData.Member[m].Property[j].EnumProp.FullName)
          end
          file:write(string.format('[%8X] %016X %s\n',readInteger(ObjectData.Member[m].Property[j].Address+UObject.Offset),ObjectData.Member[m].Property[j].Address,name))
        end
        end
    end



      end
    end
    elseif readPointer(readPointer(pointersss))then file:write(string.format('[%08u] %016X %s\n',readInteger(pointersss+UObject.ObjectId),pointersss,'invalid object')) totalobject=totalobject+1 end
  end
  Threadlist[#Threadlist]=nil
end
if syntaxcheck then return end
[ENABLE]

starttime=os.clock()

totalobject=0
local Path = 'C:\\Users\\'..os.getenv('USERNAME')..'\\Desktop\\'
local filename= string.format('[%s] ObjectsDump.txt',process)
file,err = io.open(Path..filename, 'w')
assert(file,err)
print(Path..filename)
file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
Threadlist={}

local count=ObjectsPerThread
  local sizess= UObjectMul*count
  local ObjectId=UObject.ObjectId
  local num,start,stop
  local size,pointersss=targetIs64Bit() and 8 or 4

  for i=0,0x1000,size do
    pointersss=readPointer(GUObjectAddress+i)
    if not readPointer(pointersss) then break end
    size=getregionsize(pointersss)
    num,start,stop=count,0,0
    for j=0,math.floor(size/sizess) do
      start=stop
      stop=stop+num
      --print(start..'~'..stop)
      Threadlist[#Threadlist+1]=createThread(BasicObjectdump(this,pointersss,start,stop-1))
    end
  end
  for i=0,10000 do
    if #Threadlist==0 then break end
    sleep(1)
  end

file:close()

print(string.format('\nA Total of %u might be objects has been dumped in %.3f seconds',totalobject,os.clock()-starttime))

shellExecute(Path..filename)



--  end
--end

[DISABLE]

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26226</ID>
          <Description>"UE Name Dumper Algo"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
 ue4parsetableFNamePool()
 local UEver,size=UE4ver
 if readPointer(FNameString) or string.find(process,'StateOfDecay2')then size=0xFFFFFFFF
 elseif UEver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
 elseif not UE3 then size=(#FNameDict&lt;&lt;0xE)-1
 else size=math.floor(FNameDict[1]/(targetIs64Bit() and 8 or 4)) end

 local Path = 'C:\\Users\\'..os.getenv('USERNAME')..'\\Desktop\\'
 local filename= string.format('[%s] NamesDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UEver,os.date()))
 totalname=0
 starttime=os.clock()
 local acclen,isNoIndex=0,isMassEffect
 local i=0
 while i&lt;size do
   local name=FNameStringAlgo(i+acclen,true)
   if name and name:len()&lt;200 and name:len()&gt;3 and not string.find(name,'%c')  then
     --print(name)
     local strid=string.format('%08X',i+acclen)
     file:write(string.format('[%s] %s\n',strid,name))
     if isNoIndex then acclen=acclen+name:len()end
     totalname=totalname+1
     if UEver&gt;=23 then i=i+(name:len()&gt;&gt;1) end
   end
   i=i+1
 end

 file:close()
 print(string.format('\nA Total of %u names had been dumped in %.3f seconds',totalname,os.clock()-starttime))
 print(Path..filename)
 shellExecute(Path..filename)
[DISABLE]
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26091</ID>
          <Description>"Get GEngine"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local Object=not UE3 and StaticFindObjectAlgo('/Script/Engine.GameEngine') or StaticFindObjectAlgo('Engine.GameEngine')
if not Object then error('cant find Class GameEngine')end
Object=ObjectLists[Object]
local temp=Object
for i=0,4 do
  if Object.Uper and Object.Uper[1] then Object=Object.Uper[1] else break end
end
for i=1,#Object.Instance do
  if not string.find(Object.Instance[i].Name,'Default') then Object=Object.Instance[i] break end
end
if Object.Type=='Class' then
  Object=temp
  for i=1,#Object.Instance do
    if not string.find(Object.Instance[i].Name,'Default') then Object=Object.Instance[i] break end
  end
end
local rec=getAddressList().getMemoryRecordByDescription('1~2 ViewPort')
print(string.format('%X : %s %s',Object.Address,Object.Type,Object.FullName))
local result,pointer,flag1=pointerscan(Object.Address)
for i=1,#result do
  flag1=nil
  pointer=getAddress(result[i])
  print(result[i])
  if inModule(pointer)and pointer%4==0  then unregisterSymbol('GEngine')registerSymbol('GEngine',pointer,true)
    for k=0,100000 do if readPointer(pointer)~=Object.Address then flag1=true break end end
    if not flag1 then break end
  elseif pointer%4==0 then
    unregisterSymbol('GEngine')registerSymbol('GEngine',pointer,true)
  end
end
    local object,pointer,pointer2=readPointer('GEngine')
    for i=UObject.super,0x200,4 do
      pointer=readPointer(object+i)
      if readPointer(pointer) and GetFullNameAlgo(pointer) and GetFullNameAlgo(pointer):find('Client')then
        UEMember['engine.client']=i
        for j=UObject.super,0x200,4 do
          pointer2=readPointer(pointer+j)
          if readPointer(pointer2) and GetFullNameAlgo(pointer2) and GetFullNameAlgo(pointer2):find('Viewport')then
            UEMember['client.viewport']=j
            if rec.OffsetCount==4 then
              for i=0,rec.OffsetCount-1 do
                if i+1&lt;rec.OffsetCount then rec.OffsetText[i]=rec.OffsetText[i+1]end
              end
              rec.OffsetCount=3
            end
          end
        end
        for j=UObject.super,0x200,4 do
          pointer2=readPointer(pointer+j)
          if readPointer(pointer2) and readPointer(readPointer(pointer2)) and GetFullNameAlgo(readPointer(pointer2)) and GetFullNameAlgo(readPointer(pointer2)):find('Viewport')then
            UEMember['client.viewport']=j
            if rec.OffsetCount==3 then
              rec.OffsetCount=4
              for i=rec.OffsetCount-1,0,-1 do
                if i-1&gt;=0 then rec.OffsetText[i]=rec.OffsetText[i-1]
                else rec.OffsetText[i]=0 end
              end
            end
            goto done
          end
        end
      end
    end

::done::


[DISABLE]
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26124</ID>
          <Description>"Cheat command"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
for i=memrec.Count-1,0,-1 do
  memoryrecord_delete(memrec.Child[i])
end
[ENABLE]
local list,str={}
for i,v in pairs(ObjectTable) do
  if v.Type=='Function' and v.FullName:find('Cheat') then
    str=v.FullName--:sub(v.FullName:find('%.')+1,v.FullName:len())
    if v.Member and #v.Member&gt;0 then
      str=str..'  ('
      for j=1,#v.Member do
        str=string.format('%s %s %s ,',str,v.Member[j].Type,v.Member[j].Name)
      end
      str=str:sub(1,str:len()-1)..' )\n'
    else str=str..'\n'end
    list[#list+1]=str
  end
end

local rec = getAddressList().createMemoryRecord()
rec.setDescription('List (ReadMe)')
rec.VarType='vtAutoAssembler'
rec.appendToEntry(memrec)
rec.DontSave=true
rec.Script=table.concat(list)--string.format('{\n%s\n}\n[ENABLE]\n[DISABLE]',)

[DISABLE]



</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26123</ID>
          <Description>"Find UObject::ProcessEvent &amp; StaticConstructObject_Internal "</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local result=sigscan(targetIs64Bit()and'48 89 54 24 28 48 89 4C 24 20 45 33 C9'or'53 53 51 53 53 53 55 57 50 56',process)
if result[1] then unregisterSymbol('StaticConstructObject')registerSymbol('StaticConstructObject',GetNameFromAddress(followcall(result[1],0x20)),true) end

if readPointer('StaticConstructObject')then printf('StaticConstructObject_Internal: %X',getAddress('StaticConstructObject'))end

local list,pointer,name=readPointer(ObjectTable[1].Address),{}
for i=0,100 do
  pointer=readPointer(list+i*(targetIs64Bit() and 8 or 4))
  if readPointer(pointer) and getFuncSize(pointer)&gt;0x20 and #findOpcodes(pointer,'push',0x30)&gt;2 then
    name=GetFullNameSafeAlgo(checkFuncReg(pointer)[2])
    if name and name:find('Function')then

      printf('%X:%X:%s',i*8,pointer,getNameFromAddress(pointer))
      local k=0
      for j=0,10 do
        local ext, opc, byt, add=splitDisassembledString(disassemble(pointer+k))
        print(opc)
        k=k+getInstructionSize(pointer+k)
      end

      unregisterSymbol('UObject::ProcessEvent')registerSymbol('UObject::ProcessEvent',pointer,true)
      break

    end
  end
end
if not readPointer('UObject::ProcessEvent') then print('UObject::ProcessEvent not found...')
else printf('UObject::ProcessEvent: %X',pointer)end

local Object,Object2,Object3,StaticConstructObject=StaticFindObjectAlgo('/Script/Engine.PlayerController','PlayerController')
if not Object then error('cant find Class PlayerController')end

local func,func2=getAddressSafe('Function /Script/Engine.PlayerController:EnableCheats')
if not func then func=getAddressSafe('Function Engine.PlayerController:EnableCheats')end

local instance=ObjectLists[Object].Instance and ObjectLists[Object].Instance[1] or SaveObject(getAddress(not UE3 and '[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]' or '[[[[GEngine]+GamePlayers]+0]+0+Player.Actor]'))

printf('%X:%s %s',instance.Address,instance.Type,instance.FullName)

local ext, opc, byt, add=splitDisassembledString(disassemble(findOpcode(func,'jmp',getFuncSize(func))))

func=readPointer(readPointer(instance.Address)+getAddress(opc:sub(string.find(opc,'+')+1,opc:len()-1)))
printf('%X',func)
if getFuncSize(func)&lt;0x50 then
  func2=findOpcode(func,'jmp',getFuncSize(func))
  if not func2 then func2=findOpcode(func,'call',getFuncSize(func)) end
  ext, opc, byt, add=splitDisassembledString(disassemble(func2))
  func=readPointer(readPointer(instance.Address)+getAddress(opc:sub(string.find(opc,'+')+1,opc:len()-1)))
end
local ext, opc, byt, add=splitDisassembledString(disassemble(func))
if opc:find('jmp') then func=getAddress(followjmp(func,1)) end

printf('APlayerController::AddCheats: %X',func)

UE_function.deleteSymbol('APlayerController::AddCheats')
UE_function.addSymbol('UE_function','APlayerController::AddCheats',func,getFuncSize(func))

list=findOpcodes(func,'call',getFuncSize(func))
for i=1,#list do
  pointer=followcall(list[i],1)
  if readPointer(pointer) then StaticConstructObject=pointer print(pointer)end
end
print(StaticConstructObject)

if not StaticConstructObject then error('StaticConstructObject not found!')end

ext, opc, byt, add=splitDisassembledString(disassemble(StaticConstructObject))
if opc:find('jmp') then StaticConstructObject=followjmp(StaticConstructObject,1) end
StaticConstructObject=getAddress(StaticConstructObject)

if #findOpcodes(StaticConstructObject,'push',0x30)&lt;2 then

  local list=findOpcodes(StaticConstructObject,'call',getFuncSize(StaticConstructObject))
  StaticConstructObject=nil
  for i=1,#list do
    if readPointer(followcall(list[i],1)) and  #findOpcodes(followcall(list[i],1),'push',0x20)&gt;5 then StaticConstructObject=getAddress(followcall(list[i],1)) break end
  end
  if not StaticConstructObject then StaticConstructObject=getAddress(findLastCall(StaticConstructObject)) end
end
printf('StaticConstructObject_internal: %X',StaticConstructObject)
unregisterSymbol('StaticConstructObject')registerSymbol('StaticConstructObject',StaticConstructObject,true)


func2=getAddress('Function /Script/Engine.PlayerController:ConsoleKey')
local list,spointer,pointer=findOpcodes(func2,'call',getFuncSize(func2))
for i=1,#list do
  pointer=followcall(list[i],1)
  if not readPointer(pointer) and not pointer:find('*') then
    func2=readPointer(readPointer(instance.Address)+getAddress(pointer:sub(string.find(pointer,'+')+1,pointer:len()-1)))
    break
  end
end
printf('APlayerController::ConsoleKey: %X',func2)
[DISABLE]


</AssemblerScript>
          <CheatEntries>
            <CheatEntry>
              <ID>26081</ID>
              <Description>"Construct Console"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local Console

if not readPointer('[[GEngine]+GameEngine.ConsoleClass]')then
  local Data=ObjectLists[StaticFindObjectAlgo('/Script/Engine.Console','Engine.Console')]
  if Data.Uper and Data.Uper[1] then Data=Data.Uper[1] end
  writePointer('[GEngine]+GameEngine.ConsoleClass',Data.Address)
end

local banana=allocateMemory(0x100)

local Str= '[[GEngine]+GameEngine.GameViewport]'
local ClassStr='[[GEngine]+GameEngine.ConsoleClass]'

writePointer(banana,getAddress(ClassStr))
writePointer(banana+8,getAddress(Str))

if readPointer('UObject::ProcessEvent') then
  Console=ProcessEventCall(getAddress('StaticConstructObject'),string.format(([[
mov rcx,%X
mov rdx,%X
xor rax,rax
push rax
push rax
push rax
push rax
push rax
push rax
push rax
push rax
push rdx
push rcx
%s
  ]]),UE4ver&lt;=26 and getAddress(ClassStr) or banana , UE4ver&lt;=26 and getAddress(Str) or getAddress(ClassStr) ,targetIs64Bit() and 'xor r8,r8\nxor r9,r9' or ''))
else
  Console=executeCodeEx
  (
    0,nil,
    getAddress('StaticConstructObject'),
    UE4ver&lt;=26 and getAddress(ClassStr) or banana,
    UE4ver&lt;=26 and getAddress(Str) or getAddress(ClassStr),
    0,0,0,0,0,0,0
  )
end

deAlloc(banana)
if not Console or Console==0 then error('Console not constructed, wrong function ?') end
writePointer(Str..'+GameViewportClient.ViewportConsole',Console)
print('Console constructed...')
[DISABLE]
--"NewObject with empty name can't be used to create default subobjects"
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>26127</ID>
              <Description>"Construct CheatManager"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local CheatManager

local banana=allocateMemory(0x100)
local Str= UE4ver&gt;7 and '[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]' or '[[[[GEngine]+GamePlayers]+0]+0+Player.Actor]'
local ClassStr=string.format('[%s+PlayerController.CheatClass]',Str)

writePointer(banana,getAddress(ClassStr))
writePointer(banana+8,getAddress(Str))

if readPointer('UObject::ProcessEvent') then
  CheatManager=ProcessEventCall(getAddress('StaticConstructObject'),string.format(([[
mov rcx,%X
mov rdx,%X
xor rax,rax
push rax
push rax
push rax
push rax
push rax
push rax
push rax
push rax
push rdx
push rcx
%s
  ]]),UE4ver&lt;=26 and getAddress(ClassStr) or banana , UE4ver&lt;=26 and getAddress(Str) or getAddress(ClassStr) ,targetIs64Bit() and 'xor r8,r8\nxor r9,r9' or ''))
else
  CheatManager=executeCodeEx
  (
    0,nil,
    getAddress('StaticConstructObject'),
    UE4ver&lt;=26 and getAddress(ClassStr) or banana,
    UE4ver&lt;=26 and getAddress(Str) or getAddress(ClassStr),
    0,0,0,0,0,0,0
  )
end

if not CheatManager or CheatManager==0 then error('CheatManager not constructed, wrong function ?') end
writePointer(Str..'+PlayerController.CheatManager',CheatManager)
print('CheatManager constructed...')
[DISABLE]
--"NewObject with empty name can't be used to create default subobjects"
</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>26202</ID>
              <Description>"2 ProcessEvent (Edit Me)"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]


local ufunction=StaticFindObjectAlgo('Engine.CheatManager:Fly')

local instance=getAddressSafe('[[[[[GEngine]+Engine.Client]+Client.ViewPort]+0+ViewPort.Actor]+0+PlayerController.CheatManager]')
if not readPointer(instance) then instance=getAddress('[[[[[[GEngine]+Engine.Client]+Client.ViewPort]+0]+0+ViewPort.Actor]+0+PlayerController.CheatManager]')end


ProcessEvent(instance,ufunction,'')


[DISABLE]

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>26151</ID>
              <Description>"3~4 ProcessEvent (Edit Me)"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local param=allocateMemory(0x100)

local ufunction=StaticFindObjectAlgo('/Script/Engine.CheatManager:Fly','Engine.CheatManager:Fly')


local Str= not UE3 and '[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]' or '[[[[GEngine]+GamePlayers]+0]+0+Player.Actor]'


local instance=getAddress(string.format('[%s+PlayerController.CheatManager]',Str))


ProcessEvent(instance,ufunction,param)
deAlloc(param)
[DISABLE]

</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>26119</ID>
          <Description>"Create Struct"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local str,Address
str=inputQuery('CreateStructure', 'Input FullName of Class or Address of Class', '/Script/Engine.GameEngine')
if str and str~='' then
  Address=getAddressSafe(str)
  if not Address then  Address=StaticFindObjectAlgo(str)end
  if Address then Address=SaveObject(Address)end
  if not Address then error("Can't find "..str..', either invalid Object Address or invalid FullName')
  else
    SaveAndRemoveStruct()
    local Struct=ue4createstruct(Address)
    Struct.addToGlobalStructureList()
    createStructureForm(nil,nil,Struct.Name)
  end
end
[DISABLE]
</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26118</ID>
          <Description>"Print Fields/Members 's Classes used"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local AddressList,str,strtable,FullName=getAddressList(),'{',{}
for i=0,AddressList.Count-1 do
  if AddressList[i].Address~='' then
    FullName=AddressList[i].Address:gsub('+','')
    FullName=UEMemberClassFullName[FullName:lower()]
    if FullName and not strtable[FullName] then strtable[FullName]=FullName str=string.format("%s'%s',\n",str,FullName) end
  end
  for j=0,AddressList[i].OffsetCount-1 do
    if AddressList[i].OffsetText[j]~='' then
      FullName=AddressList[i].OffsetText[j]:gsub('+','')
      FullName=UEMemberClassFullName[FullName:lower()]

      if FullName and not strtable[FullName] then strtable[FullName]=FullName str=string.format("%s'%s',\n",str,FullName) end
    end
  end
end

print(str:sub(0,str:len()-2)..'}')

[DISABLE]

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26204</ID>
          <Description>"4 Example Script"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>26040</ID>
              <Description>"NoClip &amp; Fly                                            Numpad6 :Toggle, Space :Up, LeftCtrl :Down"</Description>
              <Options moHideChildren="1" moDeactivateChildrenAsWell="1"/>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{$lua}
if syntaxcheck then return end
local str1='[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]'
[ENABLE]

--[[
Enum /Script/Engine.EMovementMode
0:MOVE_None
1:MOVE_Walking
2:MOVE_NavWalking
3:MOVE_Falling
4:MOVE_Swimming
5:MOVE_Flying
6:MOVE_Custom
7:MOVE_MAX

local list=+0x40
for i=0,readInteger(list+8)-1 do
local pointer=readPointer(list)+i*0x10
local enum=readInteger(pointer+8)
local name=FNameString(pointer)
print(enum..':'..name)
end
]]


if not RelativeLocationZoffset then
  local address=getAddress('['..str1..'+Character.CapsuleComponent]')
  local value=readInteger(address+getAddress('ActorComponent.RelativeLocation+Vector.Z'))
  local list=groupscan(string.format('4:%u',value),address,address+0x1000)
  RelativeLocationZoffset={}
  for i=1,#list do
    RelativeLocationZoffset[i]=getAddress(list[i])-address
  end
end

local address=getAddressSafe(str1..'+Actor.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) &amp; ~ getAddress('Actor.bActorEnableCollision.Bit')
writeBytes(address,bActorEnableCollision)
end

updown = createTimer()
updown.Interval = 5
updown.OnTimer = function(t)
  local address=getAddressSafe('['..str1..'+Character.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_SPACE) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])+20)
      end
    end
    if isKeyPressed(VK_LCONTROL) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])-20)
      end
    end
  end
  local address=getAddressSafe('['..str1..'+Character.CharacterMovement]+MovementComponent.MovementMode')
  if address then
  writeBytes(address,5)
  end
end




[DISABLE]
updown.destroy()

local address=getAddressSafe(str1..'+Actor.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) | getAddress('Actor.bActorEnableCollision.Bit')
writeBytes(address,bActorEnableCollision)
end

local address=getAddressSafe('['..str1..'+Character.CharacterMovement]+MovementComponent.MovementMode')
if address then
writeBytes(address,1)
end
</AssemblerScript>
              <Hotkeys>
                <Hotkey>
                  <Action>Toggle Activation</Action>
                  <Keys>
                    <Key>102</Key>
                  </Keys>
                  <ID>0</ID>
                </Hotkey>
              </Hotkeys>
              <CheatEntries>
                <CheatEntry>
                  <ID>26041</ID>
                  <Description>"WASD"</Description>
                  <LastState/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
wasd = createTimer()
wasd.Interval = 5
wasd.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_S) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)+20)
      end
    end
    if isKeyPressed(VK_W) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)-20)
      end
    end
    if isKeyPressed(VK_A) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)+20)
      end
    end
    if isKeyPressed(VK_D) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)-20)
      end
    end
  end
end

[DISABLE]
wasd.destroy()
</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>26039</ID>
              <Description>"bCanBeDamaged false (Godmode)      Numpad4 :Deactive, Numpad5 :Active"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{$lua}
if syntaxcheck then return end
local str1='[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Actor.bCanBeDamaged'
[ENABLE]
--CanBeDamaged = createTimer()
--CanBeDamaged.setInterval(1000)
--CanBeDamaged.OnTimer = function()
local address=getAddressSafe(str1)
if address then
local bCanBeDamaged=readBytes(address,1) &amp; ~ getAddress('Actor.bCanBeDamaged.Bit')
writeBytes(address,bCanBeDamaged)
end
--end
 
 
[DISABLE]
--CanBeDamaged.destroy()

local address=getAddressSafe(str1)
if address then
local bCanBeDamaged=readBytes(address,1) | getAddress('Actor.bCanBeDamaged.Bit')
writeBytes(address,bCanBeDamaged)
end
</AssemblerScript>
              <Hotkeys>
                <Hotkey>
                  <Action>Activate</Action>
                  <Keys>
                    <Key>101</Key>
                  </Keys>
                  <ID>0</ID>
                </Hotkey>
                <Hotkey>
                  <Action>Deactivate</Action>
                  <Keys>
                    <Key>100</Key>
                  </Keys>
                  <ID>1</ID>
                </Hotkey>
              </Hotkeys>
            </CheatEntry>
            <CheatEntry>
              <ID>26025</ID>
              <Description>"Jump Multiplier                                       Numpad0 :Deactive, Numpad1 :Active &amp; Increase"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{$lua}
jumpmultiplier=1
if syntaxcheck then return end
local str1='[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]'
local str2=str1..'CharacterMovementComponent.JumpZVelocity'
local str3=str1..'CharacterMovementComponent.MaxAcceleration'
local str4=str1..'CharacterMovementComponent.AirControl'
if not jumpdefault then jumpdefault=readFloat(str2)&lt;100 and 100 or readFloat(str2) end
if not MaxAccelerationdefault then MaxAccelerationdefault=readFloat(str3)end
if not AirControldefault then AirControldefault=readFloat(str4)end
[ENABLE]
jumpmuti=createHotkey(function()jumpmultiplier=jumpmultiplier+0.5 end,VK_NUMPAD1)
jump = createTimer()
jump.setInterval(100)
jump.OnTimer = function()
local address=getAddressSafe(str2)
local address2=getAddressSafe(str3)
local address3=getAddressSafe(str4)
if address then writeFloat(address,jumpdefault*jumpmultiplier)
writeFloat(address2,MaxAccelerationdefault*jumpmultiplier)
writeFloat(address3,AirControldefault*jumpmultiplier)
end
end
[DISABLE]
jump.destroy()
jumpmuti.destroy()
local address=getAddressSafe(str2)
local address2=getAddressSafe(str3)
local address3=getAddressSafe(str4)
if address then writeFloat(address,jumpdefault)
writeFloat(address2,MaxAccelerationdefault)
writeFloat(address3,AirControldefault)
end

</AssemblerScript>
              <Hotkeys>
                <Hotkey>
                  <Action>Activate</Action>
                  <Keys>
                    <Key>97</Key>
                  </Keys>
                  <ID>0</ID>
                </Hotkey>
                <Hotkey>
                  <Action>Deactivate</Action>
                  <Keys>
                    <Key>96</Key>
                  </Keys>
                  <ID>1</ID>
                </Hotkey>
              </Hotkeys>
            </CheatEntry>
            <CheatEntry>
              <ID>26026</ID>
              <Description>"MovementSpeed Multiplier                   Numpad2 :Deactive, Numpad3 :Active &amp; Increase"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>{$lua}
speedvarmutiplier=1
if syntaxcheck then return end
local str1={'[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]+CharacterMovementComponent.MaxWalkSpeed'
,'[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]+CharacterMovementComponent.MaxWalkSpeedCrouched'
,'[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]+CharacterMovementComponent.MaxSwimSpeed'
,'[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]+CharacterMovementComponent.MaxFlySpeed'
,'[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]+CharacterMovementComponent.MaxCustomMovementSpeed'
,'[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]+CharacterMovementComponent.MaxAcceleration'
}

if not speedvar then
  speedvar={}
  for i=1,#str1 do
    speedvar[i]=readFloat(str1[i])
  end
end

[ENABLE]
speedvarmuti=createHotkey(function() speedvarmutiplier=speedvarmutiplier+0.5 end,VK_NUMPAD3)
speedv = createTimer()
speedv.setInterval(100)
speedv.OnTimer = function()
  for i=1,#str1 do
    address=getAddressSafe(str1[i])
    if address then writeFloat(address,speedvar[i]*speedvarmutiplier)end
  end
end
[DISABLE]
speedv.destroy()
speedvarmuti.destroy()

for i=1,#str1 do
  address=getAddressSafe(str1[i])
  if address then writeFloat(address,speedvar[i]*speedvarmutiplier)end
end
speedvar=nil
</AssemblerScript>
              <Hotkeys>
                <Hotkey>
                  <Action>Activate</Action>
                  <Keys>
                    <Key>99</Key>
                  </Keys>
                  <ID>0</ID>
                </Hotkey>
                <Hotkey>
                  <Action>Deactivate</Action>
                  <Keys>
                    <Key>98</Key>
                  </Keys>
                  <ID>1</ID>
                </Hotkey>
              </Hotkeys>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>26191</ID>
          <Description>"1~2 ViewPort"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <ShowAsSigned>0</ShowAsSigned>
          <GroupHeader>1</GroupHeader>
          <Address>GEngine</Address>
          <Offsets>
            <Offset>0</Offset>
            <Offset>Client.ViewPort</Offset>
            <Offset>Engine.Client</Offset>
          </Offsets>
          <CheatEntries>
            <CheatEntry>
              <ID>26196</ID>
              <Description>"Console"</Description>
              <LastState Value="" RealAddress="00000000"/>
              <ShowAsSigned>0</ShowAsSigned>
              <GroupHeader>1</GroupHeader>
              <Address>+ViewPort.Console</Address>
              <Offsets>
                <Offset>0</Offset>
                <Offset>Console</Offset>
                <Offset>Master</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>26220</ID>
              <Description>"Actor"</Description>
              <LastState Value="" RealAddress="00000000"/>
              <ShowAsSigned>0</ShowAsSigned>
              <GroupHeader>1</GroupHeader>
              <Address>+ViewPort.Actor</Address>
              <Offsets>
                <Offset>0</Offset>
              </Offsets>
              <CheatEntries>
                <CheatEntry>
                  <ID>26221</ID>
                  <Description>"Pawn"</Description>
                  <LastState Value="" RealAddress="00000000"/>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>+PlayerController.Pawn</Address>
                  <Offsets>
                    <Offset>0</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>26222</ID>
                  <Description>"CheatManager"</Description>
                  <LastState Value="" RealAddress="00000000"/>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>+PlayerController.CheatManager</Address>
                  <Offsets>
                    <Offset>0</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>26223</ID>
                  <Description>"bGodMode"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Binary</VariableType>
                  <BitStart>1</BitStart>
                  <BitLength>1</BitLength>
                  <ShowAsBinary>0</ShowAsBinary>
                  <Address>+bGodMode</Address>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>26156</ID>
          <Description>"3 LocalPlayer"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <ShowAsSigned>0</ShowAsSigned>
          <GroupHeader>1</GroupHeader>
          <Address>GEngine</Address>
          <Offsets>
            <Offset>0</Offset>
            <Offset>0</Offset>
            <Offset>GamePlayers</Offset>
          </Offsets>
          <CheatEntries>
            <CheatEntry>
              <ID>26157</ID>
              <Description>"PlayerController"</Description>
              <LastState Value="" RealAddress="00000000"/>
              <ShowAsSigned>0</ShowAsSigned>
              <GroupHeader>1</GroupHeader>
              <Address>+Player.Actor</Address>
              <Offsets>
                <Offset>0</Offset>
              </Offsets>
              <CheatEntries>
                <CheatEntry>
                  <ID>26158</ID>
                  <Description>"CheatManager"</Description>
                  <LastState Value="" RealAddress="00000000"/>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>+PlayerController.CheatManager</Address>
                  <Offsets>
                    <Offset>0</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>26161</ID>
                  <Description>"Pawn"</Description>
                  <LastState Value="" RealAddress="00000000"/>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>+PlayerController.Pawn</Address>
                  <Offsets>
                    <Offset>0</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>26178</ID>
                  <Description>"bGodMode"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Binary</VariableType>
                  <BitStart>1</BitStart>
                  <BitLength>1</BitLength>
                  <ShowAsBinary>0</ShowAsBinary>
                  <Address>+bGodMode</Address>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>26134</ID>
          <Description>"3~4 ViewportConsole"</Description>
          <LastState Value="" RealAddress="00000000"/>
          <ShowAsSigned>0</ShowAsSigned>
          <GroupHeader>1</GroupHeader>
          <Address>[Gengine]+GameViewport</Address>
          <Offsets>
            <Offset>0</Offset>
            <Offset>ViewportConsole</Offset>
          </Offsets>
        </CheatEntry>
        <CheatEntry>
          <ID>26052</ID>
          <Description>"4 UWorld"</Description>
          <LastState Value="" RealAddress="00000000"/>
          <ShowAsSigned>0</ShowAsSigned>
          <GroupHeader>1</GroupHeader>
          <Address>GEngine</Address>
          <Offsets>
            <Offset>0</Offset>
            <Offset>GameViewportClient.World</Offset>
            <Offset>Engine.GameViewport</Offset>
          </Offsets>
        </CheatEntry>
        <CheatEntry>
          <ID>25848</ID>
          <Description>"4 LocalPlayer"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <ShowAsSigned>0</ShowAsSigned>
          <GroupHeader>1</GroupHeader>
          <Address>GEngine</Address>
          <Offsets>
            <Offset>0</Offset>
            <Offset>0</Offset>
            <Offset>GameInstance.LocalPlayers</Offset>
            <Offset>Engine.GameInstance</Offset>
          </Offsets>
          <CheatEntries>
            <CheatEntry>
              <ID>26131</ID>
              <Description>"PlayerController"</Description>
              <LastState Value="" RealAddress="00000000"/>
              <ShowAsSigned>0</ShowAsSigned>
              <GroupHeader>1</GroupHeader>
              <Address>+Player.PlayerController</Address>
              <Offsets>
                <Offset>0</Offset>
              </Offsets>
              <CheatEntries>
                <CheatEntry>
                  <ID>26133</ID>
                  <Description>"CheatManager"</Description>
                  <LastState Value="" RealAddress="00000000"/>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>+PlayerController.CheatManager</Address>
                  <Offsets>
                    <Offset>0</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>26188</ID>
                  <Description>"Pawn"</Description>
                  <LastState Value="" RealAddress="00000000"/>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>+Actor.Pawn</Address>
                  <Offsets>
                    <Offset>0</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>26126</ID>
                  <Description>"Character"</Description>
                  <LastState Value="" RealAddress="00000000"/>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>+Actor.Character</Address>
                  <Offsets>
                    <Offset>0</Offset>
                  </Offsets>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26125</ID>
                      <Description>"CustomTimeDilation"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>+CustomTimeDilation</Address>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>25853</ID>
                      <Description>"CharacterMovement"</Description>
                      <LastState Value="" RealAddress="00000000"/>
                      <ShowAsSigned>0</ShowAsSigned>
                      <GroupHeader>1</GroupHeader>
                      <Address>+Character.CharacterMovement</Address>
                      <Offsets>
                        <Offset>0</Offset>
                      </Offsets>
                      <CheatEntries>
                        <CheatEntry>
                          <ID>25854</ID>
                          <Description>"JumpZVelocity"</Description>
                          <ShowAsSigned>0</ShowAsSigned>
                          <VariableType>Float</VariableType>
                          <Address>+CharacterMovementComponent.JumpZVelocity</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>25855</ID>
                          <Description>"MaxWalkSpeed"</Description>
                          <ShowAsSigned>0</ShowAsSigned>
                          <VariableType>Float</VariableType>
                          <Address>+CharacterMovementComponent.MaxWalkSpeed</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>25857</ID>
                          <Description>"MaxWalkSpeedCrouched"</Description>
                          <ShowAsSigned>0</ShowAsSigned>
                          <VariableType>Float</VariableType>
                          <Address>+CharacterMovementComponent.MaxWalkSpeedCrouched</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>25858</ID>
                          <Description>"MaxAcceleration"</Description>
                          <ShowAsSigned>0</ShowAsSigned>
                          <VariableType>Float</VariableType>
                          <Address>+CharacterMovementComponent.MaxAcceleration</Address>
                        </CheatEntry>
                      </CheatEntries>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>26049</ID>
      <Description>"Tools"</Description>
      <Options moHideChildren="1"/>
      <LastState Value="" RealAddress="00000000"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>26048</ID>
          <Description>"FNamePool scanner"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

print('------------------')
local isUnicode=false
local strlist,result,result2,result3,pointer1,pointer2,pointer3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  result=stringscan('IntProperty',getAddressSafe(strlist[i]),getAddressSafe(strlist[i]..'+50'),isUnicode)
  if #result&gt;0 then
    result=stringscan('None',getAddressSafe(strlist[i]..'-50'),getAddressSafe(strlist[i]),isUnicode)
    print(strlist[i])
    if #result&gt;0 then
      if string.sub(strlist[i],strlist[i]:len()-3,strlist[i]:len()-2)=='00' then
        result=pointerscan(getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00'))
        for j=1,#result do
          pointer1=readPointer(result[j]..(targetIs64Bit() and '+8' or '+4'))
          pointer1=readPointer(pointer1)
          pointer2=readPointer(result[j]..(targetIs64Bit() and '+10' or '+8'))
          pointer2=readPointer(pointer2)
          pointer3=readPointer(result[j]..(targetIs64Bit() and '+18' or '+C'))
          pointer3=readPointer(pointer3)

          if pointer1 and pointer2 and pointer3 then
            print(strlist[i]..'&lt;-'..result[j])
            unregisterSymbol('FNamePool')
            registerSymbol('FNamePool',result[j]..'-10',true)
            if ue4versioncheck()==0 then UE4ver=23 end

            if string.sub(result[j],result[j]:len()-1,result[j]:len())=='00' then
              result2=pointerscan(getAddressSafe(result[j]))
              for k=1,#result2 do
                print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
                result3=pointerscan(getAddressSafe(result2[k]),process)
                for l=1,#result3 do
                  print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l])
                  if getAddress(result3[l])%4==0 then
                    unregisterSymbol('FNamePool')
                    registerSymbol('FNamePool',result3[l],true)
                    if ue4versioncheck()==0 then UE4ver=22 end
                    goto done
                  end
                end
              end
            end
          end
        end
      end
    end
  end
end
::done::
print('done')

[DISABLE]

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26186</ID>
          <Description>"FNamePool scanner V2 (Generic)"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

print('------------------')
local isUnicode=false
local strlist,result,result2,result3,pointer1,pointer2,pointer3=stringscan('ByteProperty',nil,nil,isUnicode)
local size,val1=targetIs64Bit() and 8 or 4
for i=1,#strlist do
  print(strlist[i])
  result=pointerscan(getAddress(strlist[i])-0x50,nil,nil,getAddress(strlist[i]))
  for j=1,#result do
    val1=getAddress(strlist[i])-readPointer(result[j])
    pointer1=readPointer(getAddress(result[j])+size)

    if readPointer(pointer1) and readString(pointer1+val1,100,isUnicode) and string.find(readString(pointer1+val1,100,isUnicode),'IntProperty') then
      print(strlist[i]..'&lt;-'..result[j])
      result2=pointerscan(getAddress(result[j])-size)
      for k=1,#result2 do
        print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
        if inModule(result2[k]) and getAddress(result2[k])%4==0  then UE4ver=ue4versioncheck() unregisterSymbol('FNamePool') registerSymbol('FNamePool',result2[k],true) goto done end
        if getAddress(result2[k])%4==0 then
          result3=pointerscan(getAddress(result2[k]),process)
          for l=1,#result3 do
            print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l])
            if getAddress(result3[l])%4==0 then
              unregisterSymbol('FNamePool')
              registerSymbol('FNamePool',result3[l],true)
              goto done
            end
          end
        end
      end
    end
  end
end
::done::
print('done')
[DISABLE]

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26214</ID>
          <Description>"FNamePool scanner V3 (Unicode)"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

print('------------------')
local isUnicode=true
local strlist,result,result2,result3,pointer1,pointer2,pointer3=stringscan('ByteProperty',nil,nil,isUnicode)
local size,val1=targetIs64Bit() and 8 or 4
for i=1,#strlist do
  print(strlist[i])
  result=pointerscan(getAddress(strlist[i])-0x50,nil,nil,getAddress(strlist[i]))
  for j=1,#result do
    val1=getAddress(strlist[i])-readPointer(result[j])
    pointer1=readPointer(getAddress(result[j])+size)

    if readPointer(pointer1) and readString(pointer1+val1,100,isUnicode) and string.find(readString(pointer1+val1,100,isUnicode),'IntProperty') then
      print(strlist[i]..'&lt;-'..result[j])
      result2=pointerscan(getAddress(result[j])-size)
      for k=1,#result2 do
        print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
        if inModule(result2[k]) and getAddress(result2[k])%4==0  then UE4ver=ue4versioncheck() unregisterSymbol('FNamePool') registerSymbol('FNamePool',result2[k],true) goto done end
        if getAddress(result2[k])%4==0 then
          result3=pointerscan(getAddress(result2[k]),process)
          for l=1,#result3 do
            print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l])
            if getAddress(result3[l])%4==0 then
              unregisterSymbol('FNamePool')
              registerSymbol('FNamePool',result3[l],true)
              goto done
            end
          end
        end
      end
    end
  end
end
::done::
print('done')
[DISABLE]

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26105</ID>
          <Description>"FNamePool scanner V4 (BatmanAk)"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

print('------------------')
local isUnicode=false
local size= targetIs64Bit() and 8 or 4
local result2,result,result3,result4,pointer1,pointer2,pointer3,tempstringoffset,str,tempfnamepooloffset=stringscan('ByteProperty',nil,nil,isUnicode)
for i=1,#result2 do
--print(result2[i])
  result=pointerscan(getAddress(result2[i]..'-50'),nil,nil,getAddress(result2[i]))

  for j=1,#result do
    tempstringoffset=getAddress(result2[i])-readPointer(getAddress(result[j]))

    for k=size,0x50,4 do
      str=readString(readPointer(getAddress(result[j])+k)+tempstringoffset,0x30,isUnicode)
      if str and str=='IntProperty' then
        stringoffset=tempstringoffset
        print(result2[i]..'&lt;-'..result[j])

        result3=pointerscan(getAddress(result[j]..'-50')-k,nil,nil,getAddress(result[j]))
        for m=1,#result3 do


          pointer1=readPointer(result3[m]..(targetIs64Bit() and '+8' or '+4'))
          pointer1=readPointer(pointer1)
          pointer2=readPointer(result3[m]..(targetIs64Bit() and '+10' or '+8'))
          pointer2=readPointer(pointer2)
          pointer3=readPointer(result3[m]..(targetIs64Bit() and '+18' or '+C'))
          pointer3=readPointer(pointer3)

          if pointer1 and pointer2 and pointer3 then
            print(result2[i]..'&lt;-'..result[j]..'&lt;-'..result3[m])

            --print(result2[i]..'&lt;-'..result[j]..'&lt;-'..result3[m])
            stringoffset2=0xc--((getAddress(result[j])-readPointer(result3[m])+size)/2)-size
          --print(string.format('%X',((getAddress(result[j])-readPointer(result3[m])+size)/2)-size))
            stringmul=k

            result4=pointerscan(getAddress(result3[m])-0x50,process,nil,getAddress(result3[m])+0x50)
            for n=1,#result4 do
              print(result2[i]..'&lt;-'..result[j]..'&lt;-'..result3[m]..'&lt;-'..result4[n])
              unregisterSymbol('FNamePool') registerSymbol('FNamePool',result4[n],true)
            end
          end
        end
      end
    end
  end
end
::done::
print('done')



[DISABLE]

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26224</ID>
          <Description>"Object scanner (region)"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end

[ENABLE]
--unregisterSymbol('FNamePool')
--registerSymbol('FNamePool','libUE4.so+41DE8A4',true)
--UE4ver=nil
--if not UE4ver then ue4versioncheck()end
--ue4config()
--ue4parsetable()
ue4parsetableFNamePool()
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

local Object=FindStringFName('Object',isMassEffect,true)
if not UObject then  UObject = {} end
print(Object)

local startt=os.clock()
local address,pointer,pointer1,pointer2,pointer3,pointers,flag1=getAddress('FNamePool')
local size,sizes,regionsize,baseaddress,index=(targetIs64Bit() and 8 or 4),getregionsize(address)
sizes,regionsize,baseaddress,index=getregionsize(enumMemoryRegions()[index-5].BaseAddress)
address=baseaddress
for i=0,15 do
  sizes=sizes+getregionsize(address+sizes+1)
end
printf('%X',sizes)
sizes= sizes&gt;(0x1000000*4) and (0x1000000*4) or sizes
print(string.format('%X ~ %X',baseaddress,address+sizes))
local start,stop=baseaddress,address+sizes
unregisterSymbol('GUObjectArray')
for i=start,stop,4 do
  if readPointer(readPointer(readPointer(readPointer(i))))then
    pointer=i
    for n=0,2 do
      for o=4,(UE3 and size or 8*4),4 do
      flag1=nil
      for k=0,10*o,o do
        pointers=readPointer(pointer+k)
        if not readPointer(readPointer(pointers))
        or not readPointer(readPointer(readPointer(pointers)))
        or not inModule(readPointer(readPointer(pointers)))
        or not checkvalue(pointers,0x50,k/o,2) then break end
        if not flag1 then
          flag1=checkvalue(pointers,0x60,Object,4) pointer1=pointers
          if flag1 then
            for j=4,0x80,4 do
              pointer2=readPointer(pointer1+j)
              if readPointer(pointer2) then pointer3=FNameStringAlgo(readInteger(pointer2+flag1-pointer1),true) if pointer3 and pointer3:find('Core') then pointer3=j break end end
            end
            if not pointer3 then flag1,pointer1=nil,nil end
          end
        end
        if k==(10*o) and flag1 then print(string.format('%X %X',i,o)) registerSymbol('GUObjectArray',i,true) NOGUObjectsize=(n==0 and true or nil) goto done end
      end
      end
      pointer=readPointer(pointer)
      if not readPointer(pointer) then break end
     end
   end
end
::done::

if pointer1 and flag1 then
  printf('%X',flag1-pointer1)
  UObject.FNameIndex = flag1-pointer1
  printf('%X',pointer3)
  UObject.Outer = pointer3
  for i=4,0x80,4 do
    pointer2=readPointer(pointer1+i)
    if readPointer(pointer2) then pointer3=checkvalue(pointer2+UObject.FNameIndex,UObject.FNameIndex+4,'Class',1) if pointer3 then pointer3=i break end end
  end
  printf('%X',pointer3)
  UObject.Class = pointer3
  printf('%X %X %X : %X',UObject.Outer,UObject.FNameIndex,UObject.Class,pointer1)
end

if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
  if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
  else UE4ver=20 end
end
printf('GUObjectArray = %X',getAddressSafe('GUObjectArray'))

print('done\n')
print(os.clock()-startt)
ue4parsetable() 
[DISABLE]

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26120</ID>
          <Description>"UE3 Namepool &amp; ObjectArray scanner (using string reference)"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
print('------------------')
local result1,num,address,result2,result3,pointer,flag1,flag2,flag3=stringscan('i&gt;=0 &amp;&amp; (i&lt;ArrayNum||(i==0',process),0
local size=targetIs64Bit() and 8 or 4
if targetIs64Bit() then result2=sigscan('48 8D',process)end
for i=1,#result1 do
  print(result1[i])
  if not targetIs64Bit() then result2=pointerscan(getAddress(result1[i]),process)end
  for j=1,#result2 do
    if (targetIs64Bit() and string.find(disassemble(result2[j]),result1[i])) or not targetIs64Bit() then
      if findOpcode(result2[j],(targetIs64Bit() and '*8' or '*4'),0x100) and readPointer(readPointer(findAddress('Array',0,result2[j]..'+4',0x10)[1]))  then
        --print(result1[i]..'&lt;-'..result2[j])
        result3=findAddress('GUObjectArray',0,result2[j]..'+4')
        for k=1,#result3 do
          flag3=false
          address=getAddress(result3[k])
          flag2=ValidateFNamePool(getAddress(address))
          if flag2 then print(string.format('FNamePool=%X',getAddressSafe('FNamePool'))) end
          pointer=readPointer(address)
          if readPointer(readPointer(pointer)) then
            for m=0,1 do
              for n=0,20*size,size do
                if not readPointer(readPointer(readPointer(pointer+n))) then break end
                if n==20*size then flag3=true end
              end
              if flag3 then break end
              pointer=readPointer(pointer)
            end
          end
          if flag3 and getAddressSafe('GUObjectArray')~=getAddress(address) and getAddressSafe('FNamePool')~=getAddress(address) and getAddress(address)%4==0 and readPointer(readPointer(readPointer(address))) and readPointer(readPointer(address))%4==0 then unregisterSymbol('GUObjectArray')registerSymbol('GUObjectArray',address,true) print(string.format('GUObjectArray=%X',getAddress('GUObjectArray'))) flag1=true goto done end
          if flag1 and flag2 then goto done end
        end
        --UObjectMul=targetIs64Bit() and 8 or 4
        --if num&gt;1 then break end
      end
    end
  end
end
::done::
--[[
if not readPointer('GUObjectArray')then
  result1=stringscan('Core',process)
  for i=1,#result1 do
    print(result1[i])
    if not targetIs64Bit() then result2=pointerscan(getAddress(result1[i]),process)end
    for j=1,#result2 do
      if (targetIs64Bit() and string.find(disassemble(result2[j]),result1[i])) or not targetIs64Bit() then
        if findOpcode(result2[j],(targetIs64Bit() and '*8' or '*4'),0x100) and readPointer(readPointer(findAddress('Array',0,result2[j]..'+4',nil,nil,nil,nil,nil,nil,0x10)[1]))  then
          print(result1[i]..'&lt;-'..result2[j])
          findAddress('GUObjectArray',1,result2[j]..'+4',nil,nil,nil,nil,nil,nil,0x10)
          break
        end
      end
    end
  end
end
]]
print('done')
[DISABLE]

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26210</ID>
          <Description>"Object scanner"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript Async="1">{$lua}

if syntaxcheck then return end

[ENABLE]
--unregisterSymbol('FNamePool')
--registerSymbol('FNamePool','libUE4.so+41DE8A4',true)
--UE4ver=nil
--if not UE4ver then ue4versioncheck()end
--ue4config()
--ue4parsetable()
ue4parsetableFNamePool()

if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

local Object=FindStringFName('Object',isMassEffect,true)
if not UObject then  UObject = {} end
print(Object)
local size,pointer,pointer1,pointer2,pointer3,pointer4,pointer5,pointer6,class,fname,outer,flag1=(targetIs64Bit() and 8 or 4)
local result,result2,result3=groupscan('4:'..Object)
print(#result)
for i=1,#result do
  pointer=getAddress(result[i])-0x50

  for j=0,0x200,4 do
    pointer1=readPointer(pointer+j)
    if readPointer(readPointer(pointer1)) and readPointer(readPointer(readPointer(pointer1))) and inModule(readPointer(readPointer(pointer1)))then
      pointer2=checkvalue(pointer1,0x200,'Class',1)
      if pointer2 then
        pointer5=pointer2-pointer1

        for k=0,0x200,4 do
          pointer3=readPointer(pointer+k)
          if readPointer(readPointer(pointer3)) and readPointer(readPointer(readPointer(pointer3))) and inModule(readPointer(readPointer(pointer3)))then
            pointer4=checkvalue(pointer3,0x200,'Core',1)
            if pointer4 then
              pointer6=pointer4-pointer3
              if pointer6==pointer5 then
                pointer1=getAddress(result[i])-pointer6
                if readPointer(readPointer(pointer1)) and readPointer(readPointer(readPointer(pointer1))) and inModule(readPointer(readPointer(pointer1)))then
                  outer,fname,class=pointer+k-pointer1,pointer6,pointer+j-pointer1
                  if class&lt;0x80 and fname&lt;0x80 and outer&lt;0x80 and FNameStringAlgo(readInteger(readPointer(pointer1+class)+fname),true):len()&lt;6 then
                    printf('%X %X %X : %X',outer,fname,class,pointer1)
                    goto done
                  end
                end
              end
            end
          end
        end
      end
    end
  end
end
::done::
local strlist={}
UObject.Outer = outer
UObject.FNameIndex = fname
UObject.Class = class
result2=pointerscan(pointer1)
print(#result2)
for i=#result2,1,-1 do
  for j=0,0x160,4 do
    pointer2=getAddress(result2[i])-0x130+j
    flag1=nil
    pointer=readPointer(pointer2)
    if readPointer(readPointer(pointer)) and readPointer(readPointer(readPointer(pointer))) and inModule(readPointer(readPointer(pointer)))then
      --printf('0. %X',getAddress(result2[i])-0x130+j)
      strlist[#strlist+1]=string.format('0. %X\n',getAddress(result2[i])-0x130+j)
      for o=4,UE3 and size or 8*4,4 do
      for k=0,10*o,o do
        pointer1=readPointer(pointer2+k)
        if not readPointer(readPointer(pointer1))
        or not readPointer(readPointer(readPointer(pointer1)))
        or not inModule(readPointer(readPointer(pointer1)))
        or not checkvalue(pointer1,0x50,k/o,2)
        or not GetFullNameSafeAlgo(pointer1) then break end
        if k==(10*o) then
          printf('1. %X %X',pointer2,o) flag1=true
          UObject.ObjectId= checkvalue(readPointer(pointer2+o*2),0x200,2,2)-readPointer(pointer2+o*2)
          if pointer2%4==0 then unregisterSymbol('GUObjectArray') registerSymbol('GUObjectArray',pointer2,true)NOGUObjectsize=true end
          result=pointerscan(pointer2)
          for m=1,#result do
            pointer=getAddress(result[m])
            if pointer%4==0 then
              if inModule(pointer2) and not inModule(pointer) then break end
              printf('%X&lt;-%X',pointer2,pointer)
              unregisterSymbol('GUObjectArray') registerSymbol('GUObjectArray',pointer,true)NOGUObjectsize=nil
              if inModule(pointer) then goto done2 end
              result3=pointerscan(pointer)
              for n=1,#result3 do
                pointer3=getAddress(result3[n])
                if pointer3%4==0 then
                  printf('%X&lt;-%X&lt;-%X',pointer2,pointer,pointer3)
                  unregisterSymbol('GUObjectArray') registerSymbol('GUObjectArray',pointer3,true)NOGUObjectsize=nil
                  if inModule(pointer3) then goto done2 end
                end
              end
            end
          end
          if pointer2%0x100==0 and inModule(pointer2) then goto done2 end
        end
        if flag1 then break end
      end
      if flag1 then break end
      end
      if flag1 then break end
    end
    if flag1 then break end
  end
end
::done2::
--if not flag1 then print(table.concat(strlist))end
--[[
if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
  if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
  elseif readInteger('GUObjectArray+14')==0 then UE4ver=9
  else UE4ver=20 end
end
]]
if readPointer('GUObjectArray') then printf('GUObjectArray = %X\n',getAddress('GUObjectArray')) ue4parsetable() end
print('done\n')
[DISABLE]

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26107</ID>
          <Description>"Auto Assemble script"</Description>
          <LastState/>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>{$lua}
function GetFullName(object)
  if not GetFullNameMem then GetFullNameMem=allocateMemory(0x100)end
  executeCodeEx(0, nil, getAddress('GetFullName'), object, GetFullNameMem)
  local str=readPointer(GetFullNameMem)
  if str then str=readString(str,readInteger(GetFullNameMem+0x8)*2,true) end
  return str
end


if syntaxcheck then return end
[ENABLE]


 
 
[DISABLE]

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>26029</ID>
          <Description>"DissectCode (Memory View -&gt; Ctrl+J or (Tools -&gt; Dissect code) )"</Description>
          <Options moHideChildren="1"/>
          <LastState Value="" RealAddress="00000000"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>26028</ID>
              <Description>"Save DissectCode"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
getDissectCode().saveToFile(path)
--getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>26030</ID>
              <Description>"Load DissectCode"</Description>
              <LastState/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
--getDissectCode().saveToFile(path)
getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
</CheatTable>
